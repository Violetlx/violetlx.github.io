import{_ as s,c as a,b as e,o as p}from"./app-DlQzn5rm.js";const t="/assets/image-20211005211941309-cvniey62.png",l="/assets/image-20211005212241260-BLvs9J1B.png",i="/assets/image-20211005213526537-N-LkDBHV.png",o="/assets/image-20211005214021079-mA455uMX.png",c="/assets/image-20211005214715960-DZjl0rJe.png",r="/assets/image-20211005222757022-CQsOLxVt.png",u="/assets/image-20211005224640149-Ce2sIN8E.png",d={};function k(m,n){return p(),a("div",null,n[0]||(n[0]=[e(`<p><img src="https://artfiles.alphacoders.com/117/thumb-1920-117871.jpg" alt="Download Anime Golden Kamuy Art"></p><div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><ul><li>概述</li><li>栈的链式存储结构及实现</li><li>栈的应用</li><li>队列定义</li></ul></div><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h2><p><strong>栈是限定在尾表进行插入和删除的线性表</strong></p><p><strong>队列是只允许在一端进行插入操作,另一端进行删除操作的线性表</strong></p><ul><li><p>栈的抽象数据类型</p><blockquote><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line">ADT 栈 <span class="token punctuation">(</span>Stack<span class="token punctuation">)</span></span>
<span class="line"> Data </span>
<span class="line">   同线性表<span class="token punctuation">,</span>元素具有相同类型<span class="token punctuation">,</span>元素之间关系一对一</span>
<span class="line">Operation</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+t+`" alt="image-20211005211941309"></p></blockquote></li><li><p>栈的结构定义</p><blockquote><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">int</span> SElemType<span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line"> SelemType data<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"> <span class="token keyword">int</span> top<span class="token punctuation">;</span>  <span class="token comment">// 栈顶指针</span></span>
<span class="line"><span class="token punctuation">}</span> SqStack<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+l+`" alt="image-20211005212241260"></p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line">Status <span class="token function">Push</span><span class="token punctuation">(</span>SqStack <span class="token operator">*</span> S<span class="token punctuation">,</span>SElemType e<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line"> <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token operator">-&gt;</span>top <span class="token operator">==</span>MAXSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">     <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span></span>
<span class="line"> <span class="token punctuation">}</span></span>
<span class="line"> S<span class="token operator">-&gt;</span>top<span class="token operator">++</span><span class="token punctuation">;</span></span>
<span class="line"> S<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>S<span class="token operator">-&gt;</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span></span>
<span class="line"> <span class="token keyword">return</span> OK<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line">Status <span class="token function">Pop</span><span class="token punctuation">(</span>SqStack <span class="token operator">*</span>s<span class="token punctuation">,</span>SElemType <span class="token operator">*</span>e<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line"> <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token operator">-&gt;</span>top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span></span>
<span class="line">     <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span></span>
<span class="line"> <span class="token operator">*</span>e<span class="token operator">=</span>S<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>S<span class="token operator">-&gt;</span>top<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"> S<span class="token operator">-&gt;</span>top<span class="token operator">--</span><span class="token punctuation">;</span></span>
<span class="line"> <span class="token keyword">return</span> OK<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>eg:对于一个栈给定序列abc,试写出输出所有序列</p><ol><li>abc(a+ a- b+ b- c+ c-)</li><li>acb(a+ a-,b+,c+,c-,b-)</li><li>bac(a+,b+,b-,a-,c+,c-)</li><li>bca(a+,b+,b-,c+,c-,a-)</li><li>cba(a+,b+,c+,c-,b-,a-)</li></ol></blockquote><h4 id="两栈共享空间" tabindex="-1"><a class="header-anchor" href="#两栈共享空间"><span>两栈共享空间</span></a></h4><blockquote><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">typedef</span> <span class="token keyword">struct</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line"> SElemType data<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"> <span class="token keyword">int</span> top1<span class="token punctuation">;</span></span>
<span class="line"> <span class="token keyword">int</span> top2<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span>SqDoubleStack<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>判断满栈条件</p><p>S-&gt;top1+1 == S-&gt;top2</p><p>判断空栈条件</p></blockquote></li></ul><h2 id="栈的链式存储结构及实现" tabindex="-1"><a class="header-anchor" href="#栈的链式存储结构及实现"><span>栈的链式存储结构及实现</span></a></h2><p><img src="`+i+'" alt="images/5-Structure/image-20211005213526537.png"></p><p>链栈的空条件为 top = NULL</p><ul><li><strong>链栈的结构定义</strong></li></ul><p><img src="'+o+`" alt="images/5-Structure/image-20211005214021079.png"></p><ul><li>入栈</li></ul><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line">Status <span class="token function">Push</span> <span class="token punctuation">(</span>LinkStack <span class="token operator">*</span>S<span class="token punctuation">,</span>SElemType e<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    LinkStackptr s <span class="token operator">=</span> <span class="token punctuation">(</span>LinkStackPtr<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>StackNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    s<span class="token operator">-&gt;</span>data <span class="token operator">=</span> e<span class="token punctuation">;</span></span>
<span class="line">    s<span class="token operator">-&gt;</span>next <span class="token operator">=</span> S<span class="token operator">-&gt;</span>top<span class="token punctuation">;</span>  <span class="token comment">//将top指向s下一指针域</span></span>
<span class="line">    S<span class="token operator">-&gt;</span>top <span class="token operator">=</span> s<span class="token punctuation">;</span>   <span class="token comment">// 将top指向指针</span></span>
<span class="line">    S<span class="token operator">-&gt;</span>count<span class="token operator">++</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">return</span> OK<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>出栈</li></ul><p><img src="`+c+`" alt="image-20211005214715960"></p><p><em>栈的入栈和出栈没有任何循环操作,时间复杂度为O(1)</em></p><h2 id="栈的应用" tabindex="-1"><a class="header-anchor" href="#栈的应用"><span>栈的应用</span></a></h2><ul><li><p>递归</p><blockquote><p><em>直接调用自己或通过一系列的调用语句间接调用自己的函数</em></p><p><strong>每个递归定义必须至少有一个判断条件终止递归不在进行(即不在引用自身的条件)</strong></p><p>执行过程中使用递归工作站保存返回地址和计算中间参数及结果</p><p>递归求n阶乘</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">int</span> <span class="token function">fac</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line"><span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  </span>
<span class="line"><span class="token punctuation">}</span> </span>
<span class="line"> <span class="token keyword">else</span><span class="token punctuation">{</span></span>
<span class="line">     <span class="token keyword">return</span> <span class="token function">fac</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>n<span class="token punctuation">;</span></span>
<span class="line"> <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote></li><li><p>字符匹配(入栈,出栈逻辑判断)</p></li><li><p>字符回文判断(判断字符是否中心对称)</p></li><li><p>四则运算表达式求值</p><blockquote><p>__后缀表达式 9 3 1 - 3 * + 10 2 / + __</p><blockquote><p>从左到右遍历表达式的每个数字和符号,遇到数字进栈,遇到符号,就处于顶栈两个数字出栈,进行算数运算,其结果再次入栈</p></blockquote><p><strong>中缀表达式转后缀表达式(9 + (3 - 1) * 3 + 10 / 2 =&gt; 9 3 1 - 3 * + 10 2 / + )</strong></p><blockquote><p>从左到右遍历中缀表达式每个数字和字符,数字输出,成为后缀表达式一部分,遇到符号则与栈顶符号比较优先级(右括号或优先级低于栈顶符号)低则输出栈顶弹出并入中缀表达式__(遇右括号或优先级低于栈顶符号的输出否则输入栈)__</p></blockquote><ul><li>将中缀表达式转化为后缀表达式(栈用来进出运算符号)</li><li>将后缀表达式进行计算(栈用来进出运算数字)</li></ul></blockquote></li></ul><h2 id="队列定义" tabindex="-1"><a class="header-anchor" href="#队列定义"><span>队列定义</span></a></h2><p><strong>队列是一种先进先出FIFO的线性表,区别于栈(先进后出)</strong>,允许插入的一端为队尾,允许删除的一端为队头</p><p><strong>抽象数据类型</strong></p><blockquote><p><img src="`+r+'" alt="image-20211005222757022"></p></blockquote><p><strong>循环队列(受限制的线性表)</strong></p><blockquote><p><em>收尾相接的的顺序存储结构称为循环队列</em></p><blockquote><p><strong>循环队列判断满队与空队条件</strong></p><ul><li><strong>(rear + 1) % QueueSize == front</strong> 满队条件</li><li><strong>(rear-front+QueueSize) % QueueSize</strong> 计算队列长度公式</li><li><strong>Q-&gt;real = (Q-&gt;real+1)%QueueSize</strong> 入队尾指针加1</li><li><strong>Q-&gt;front = (Q-&gt;front+1) % QueueSize</strong> 出队头指针加1</li></ul></blockquote></blockquote><p><strong>队列的链式存储结构及实现</strong></p><blockquote><p><img src="'+u+'" alt="image-20211005224640149"></p><ul><li>判断 ar == Q-&gt;front</li><li>入队 p-&gt;next = null ; Q-&gt;rear-&gt;next = p ; Q-&gt;rear = p;</li><li>出队 Q-&gt;front-&gt;next-&gt;data</li></ul></blockquote>',26)]))}const g=s(d,[["render",k]]),b=JSON.parse('{"path":"/docs/Computer/Computer/5_Structure/5-Structure.html","title":"栈和队列","lang":"en-US","frontmatter":{"title":"栈和队列","date":"2025/07/04"},"headers":[{"level":2,"title":"概述","slug":"概述","link":"#概述","children":[]},{"level":2,"title":"栈的链式存储结构及实现","slug":"栈的链式存储结构及实现","link":"#栈的链式存储结构及实现","children":[]},{"level":2,"title":"栈的应用","slug":"栈的应用","link":"#栈的应用","children":[]},{"level":2,"title":"队列定义","slug":"队列定义","link":"#队列定义","children":[]}],"filePathRelative":"docs/Computer/Computer/5_Structure/5-Structure.md","git":{"createdTime":1751621258000,"updatedTime":1751621258000,"contributors":[{"name":"lixuan","email":"2789968443@qq.com","commits":1}]}}');export{g as comp,b as data};
