import{_ as t,c as p,b as s,o}from"./app-C7pp65Rl.js";const n="/assets/-175075619074680-B79HYyop.jpeg",r="/assets/-175075619074679-C8h_rW8W.png",a="/assets/-175075621415083-D20eXe28.png",c="/assets/-175075621415184-BfW_HQTD.png",u="/assets/-175075621415185-CRetD9E6.png",d="/assets/-175075622412589-DeIuj7qD.png",m="/assets/-175075622412590-DD2Im5e2.png",g="/assets/-175075622412691-BpgzMJhk.png",_="/assets/-175075623307795-ChpHl2qN.png",e="/assets/-1750756251659101-CWDzlCUn.png",l="/assets/-1750756251660102-DWGoWfg5.png",h={};function v(q,i){return o(),p("div",null,i[0]||(i[0]=[s('<p><img src="https://bizhi1.com/wp-content/uploads/2024/11/princess-bubblegum-adventure-time-desktop-wallpaper-4k.jpg" alt="泡泡糖公主探险活宝桌面壁纸"></p><div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>1 线程隔离</p><p>2 滑动窗口算法</p><p>3 令牌桶算法</p><p>4 漏桶算法</p><p>5 作业</p></div><p>在SpringCloud的早期版本中采用的服务保护技术叫做<code>Hystix</code>，不过后来被淘汰，替换为<code>Spring Cloud Circuit Breaker</code>，其底层实现可以是<code>Spring Retry</code>和<code>Resilience4J</code>。</p><p>不过在国内使用较多还是<code>SpringCloudAlibaba</code>中的<code>Sentinel</code>组件。</p><p>接下来，我们就分析一下<code>Sentinel</code>组件的一些基本实现原理以及它与<code>Hystix</code>的差异。</p><h2 id="_1-线程隔离" tabindex="-1"><a class="header-anchor" href="#_1-线程隔离"><span>1 线程隔离</span></a></h2><p>首先我们来看下线程隔离功能，无论是Hystix还是Sentinel都支持线程隔离。不过其实现方式不同。</p><p>线程隔离有两种方式实现：</p><ul><li><strong>线程池****隔离</strong>：给每个服务调用业务分配一个线程池，利用线程池本身实现隔离效果</li><li><strong>信号量****隔离</strong>：不创建线程池，而是计数器模式，记录业务使用的线程数量，达到信号量上限时，禁止新的请求</li></ul><p>如图：</p><p><img src="'+n+'" alt="img"></p><p>两者的优缺点如下：</p><p><img src="'+r+'" alt="img"></p><p>Sentinel的线程隔离就是基于信号量隔离实现的，而Hystix两种都支持，但默认是基于线程池隔离。</p><h2 id="_2-滑动窗口算法" tabindex="-1"><a class="header-anchor" href="#_2-滑动窗口算法"><span>2 滑动窗口算法</span></a></h2><p>在熔断功能中，需要统计异常请求或慢请求比例，也就是计数。在限流的时候，要统计每秒钟的QPS，同样是计数。可见计数算法在熔断限流中的应用非常多。sentinel中采用的计数器算法就是滑动窗口计数算法。</p><h3 id="_2-1-固定窗口计数" tabindex="-1"><a class="header-anchor" href="#_2-1-固定窗口计数"><span>2.1 固定窗口计数</span></a></h3><p>要了解滑动窗口计数算法，我们必须先知道固定窗口计数算法，其基本原理如图：</p><p><img src="'+a+'" alt="img"></p><p>说明：</p><ul><li>将时间划分为多个窗口，窗口时间跨度称为<code>Interval</code>，本例中为1000ms；</li><li>每个窗口维护1个计数器，每有1次请求就将计数器<code>+1</code>。限流就是设置计数器阈值，本例为3，图中红线标记</li><li>如果计数器超过了限流阈值，则超出阈值的请求都被丢弃。</li></ul><p>示例：</p><p><img src="'+c+'" alt="img"></p><p>说明：</p><ul><li>第1、2秒，请求数量都小于3，没问题</li><li>第3秒，请求数量为5，超过阈值，超出的请求被拒绝</li></ul><p>但是我们考虑一种特殊场景，如图：</p><p><img src="'+u+'" alt="img"></p><p>说明：</p><ul><li>假如在第5、6秒，请求数量都为3，没有超过阈值，全部放行</li><li>但是，如果第5秒的三次请求都是在4.5<sub>5秒之间进来；第6秒的请求是在5</sub>5.5之间进来。那么从第4.5~5.之间就有6次请求！也就是说每秒的QPS达到了6，远超阈值。</li></ul><p>这就是固定窗口计数算法的问题，它只能统计当前某1个时间窗的请求数量是否到达阈值，无法结合前后的时间窗的数据做综合统计。</p><p>因此，我们就需要滑动时间窗口算法来解决。</p><h3 id="_2-2-滑动窗口计数" tabindex="-1"><a class="header-anchor" href="#_2-2-滑动窗口计数"><span>2.2 滑动窗口计数</span></a></h3><p>固定时间窗口算法中窗口有很多，其跨度和位置是与时间区间绑定，因此是很多固定不动的窗口。而滑动时间窗口算法中只包含1个固定跨度的窗口，但窗口是可移动动的，与时间区间无关。</p><p>具体规则如下：</p><ul><li>窗口时间跨度<code>Interval</code>大小固定，例如1秒</li><li>时间区间跨度为<code>Interval / n</code> ，例如n=2，则时间区间跨度为500ms</li><li>窗口会随着当前请求所在时间<code>currentTime</code>移动，窗口范围从<code>currentTime-Interval</code>时刻之后的第一个时区开始，到<code>currentTime</code>所在时区结束。</li></ul><p>如图所示：</p><p><img src="'+d+'" alt="img"></p><p>限流阈值依然为3，绿色小块就是请求，上面的数字是其<code>currentTime</code>值。</p><ul><li>在第1300ms时接收到一个请求，其所在时区就是1000~1500</li><li>按照规则，currentTime-Interval值为300ms，300ms之后的第一个时区是500<sub>1000，因此窗口范围包含两个时区：500</sub>1000、1000~1500，也就是粉红色方框部分</li><li>统计窗口内的请求总数，发现是3，未达到上限。</li></ul><p>若第1400ms又来一个请求，会落在1000~1500时区，虽然该时区请求总数是3，但滑动窗口内总数已经达到4，因此该请求会被拒绝：</p><p><img src="'+m+'" alt="img"></p><p>假如第1600ms又来的一个请求，处于1500<sub>2000时区，根据算法，滑动窗口位置应该是1000</sub>1500和1500~2000这两个时区，也就是向后移动：</p><p><img src="'+g+'" alt="img"></p><p>这就是滑动窗口计数的原理，解决了我们之前所说的问题。而且滑动窗口内划分的时区越多，这种统计就越准确。</p><h2 id="_3-令牌桶算法" tabindex="-1"><a class="header-anchor" href="#_3-令牌桶算法"><span>3 令牌桶算法</span></a></h2><p>限流的另一种常见算法是令牌桶算法。Sentinel中的热点参数限流正是基于令牌桶算法实现的。其基本思路如图：</p><p><img src="'+_+'" alt="img"></p><p>说明：</p><ul><li>以固定的速率生成令牌，存入令牌桶中，如果令牌桶满了以后，多余令牌丢弃</li><li>请求进入后，必须先尝试从桶中获取令牌，获取到令牌后才可以被处理</li><li>如果令牌桶中没有令牌，则请求等待或丢弃</li></ul><p>基于令牌桶算法，每秒产生的令牌数量基本就是QPS上限。</p><p>当然也有例外情况，例如：</p><ul><li>某一秒令牌桶中产生了很多令牌，达到令牌桶上限N，缓存在令牌桶中，但是这一秒没有请求进入。</li><li>下一秒的前半秒涌入了超过2N个请求，之前缓存的令牌桶的令牌耗尽，同时这一秒又生成了N个令牌，于是总共放行了2N个请求。超出了我们设定的QPS阈值。</li></ul><p>因此，在使用令牌桶算法时，尽量不要将令牌上限设定到服务能承受的QPS上限。而是预留一定的波动空间，这样我们才能应对突发流量。</p><h2 id="_4-漏桶算法" tabindex="-1"><a class="header-anchor" href="#_4-漏桶算法"><span>4 漏桶算法</span></a></h2><p>漏桶算法与令牌桶相似，但在设计上更适合应对并发波动较大的场景，以解决令牌桶中的问题。</p><p>简单来说就是请求到达后不是直接处理，而是先放入一个队列。而后以固定的速率从队列中取出并处理请求。之所以叫漏桶算法，就是把请求看做水，队列看做是一个漏了的桶。</p><p>如图：</p><p><img src="'+e+'" alt="img"></p><p>说明：</p><ul><li>将每个请求视作&quot;水滴&quot;放入&quot;漏桶&quot;进行存储；</li><li>&quot;漏桶&quot;以固定速率向外&quot;漏&quot;出请求来执行，如果&quot;漏桶&quot;空了则停止&quot;漏水”；</li><li>如果&quot;漏桶&quot;满了则多余的&quot;水滴&quot;会被直接丢弃。</li></ul><p>漏桶的优势就是<strong>流量整型</strong>，桶就像是一个大坝，请求就是水。并发量不断波动，就如图水流时大时小，但都会被大坝拦住。而后大坝按照固定的速度放水，避免下游被洪水淹没。</p><p>因此，不管并发量如何波动，经过漏桶处理后的请求一定是相对平滑的曲线：</p><p><img src="'+l+'" alt="img"></p><p>sentinel中的限流中的排队等待功能正是基于漏桶算法实现的。漏桶算法与令牌桶相似，但在设计上更适合应对并发波动较大的场景，以解决令牌桶中的问题。</p><p>简单来说就是请求到达后不是直接处理，而是先放入一个队列。而后以固定的速率从队列中取出并处理请求。之所以叫漏桶算法，就是把请求看做水，队列看做是一个漏了的桶。</p><p>如图：</p><p><img src="'+e+'" alt="img"></p><p>说明：</p><ul><li>将每个请求视作&quot;水滴&quot;放入&quot;漏桶&quot;进行存储；</li><li>&quot;漏桶&quot;以固定速率向外&quot;漏&quot;出请求来执行，如果&quot;漏桶&quot;空了则停止&quot;漏水”；</li><li>如果&quot;漏桶&quot;满了则多余的&quot;水滴&quot;会被直接丢弃。</li></ul><p>漏桶的优势就是<strong>流量整型</strong>，桶就像是一个大坝，请求就是水。并发量不断波动，就如图水流时大时小，但都会被大坝拦住。而后大坝按照固定的速度放水，避免下游被洪水淹没。</p><p>因此，不管并发量如何波动，经过漏桶处理后的请求一定是相对平滑的曲线：</p><p><img src="'+l+'" alt="img"></p><p>sentinel中的限流中的排队等待功能正是基于漏桶算法实现的。</p><h2 id="_5-作业" tabindex="-1"><a class="header-anchor" href="#_5-作业"><span>5.作业</span></a></h2><p>尝试用自己的语言回答下列面试题：</p><ul><li>SpringCloud有哪些常用组件？分别是什么作用？</li><li>服务注册发现的基本流程是怎样的？</li><li>Eureka和Nacos有哪些区别？</li><li>Nacos的分级存储模型是什么意思？</li><li>OpenFeign是如何实现负载均衡的？</li><li>什么是服务雪崩，常见的解决方案有哪些？</li><li>Hystix和Sentinel有什么区别和联系？</li><li>限流的常见算法有哪些？</li><li>什么是CAP理论和BASE思想？</li><li>项目中碰到过分布式事务问题吗？怎么解决的？</li><li>AT模式如何解决脏读和脏写问题的？</li><li>TCC模式与AT模式对比，有哪些优缺点</li><li>RabbitMQ是如何确保消息的可靠性的？</li><li>RabbitMQ是如何解决消息堆积问题的？</li></ul>',76)]))}const x=t(h,[["render",v]]),k=JSON.parse('{"path":"/docs/Java/Heima/Microservices/Day11_MicroservicesInterview/4-MicroservicesInterview.html","title":"服务保护","lang":"en-US","frontmatter":{"title":"服务保护","date":"2025/03/06"},"headers":[{"level":2,"title":"1 线程隔离","slug":"_1-线程隔离","link":"#_1-线程隔离","children":[]},{"level":2,"title":"2 滑动窗口算法","slug":"_2-滑动窗口算法","link":"#_2-滑动窗口算法","children":[{"level":3,"title":"2.1 固定窗口计数","slug":"_2-1-固定窗口计数","link":"#_2-1-固定窗口计数","children":[]},{"level":3,"title":"2.2 滑动窗口计数","slug":"_2-2-滑动窗口计数","link":"#_2-2-滑动窗口计数","children":[]}]},{"level":2,"title":"3 令牌桶算法","slug":"_3-令牌桶算法","link":"#_3-令牌桶算法","children":[]},{"level":2,"title":"4 漏桶算法","slug":"_4-漏桶算法","link":"#_4-漏桶算法","children":[]},{"level":2,"title":"5.作业","slug":"_5-作业","link":"#_5-作业","children":[]}],"filePathRelative":"docs/Java/Heima/Microservices/Day11_MicroservicesInterview/4-MicroservicesInterview.md","git":{"createdTime":1741251281000,"updatedTime":1750756522000,"contributors":[{"name":"lixuan","email":"2789968443@qq.com","commits":2}]}}');export{x as comp,k as data};
