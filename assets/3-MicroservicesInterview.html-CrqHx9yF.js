import{_ as s,c as a,b as e,o as c}from"./app-C7pp65Rl.js";const p="/assets/-175075601713432-BnxYWeVt.png",o="/assets/-175075601713217-DWodgZTq.png",t="/assets/-175075601713218-CpBqTFgZ.png",i="/assets/-175075601713219-BNLdpKdw.png",l="/assets/-175075601713220-C8UPRjM6.png",r="/assets/-175075601713321-QWQ3yAK1.png",d="/assets/-175075601713322-CIMcAlN8.png",u="/assets/-175075601713323-DNk7k71w.png",m="/assets/-175075601713324-BV-sgNKs.png",g="/assets/-175075601713325-lcBCXbSd.png",k="/assets/-175075601713326-DzZLWe2T.png",v="/assets/-175075601713327-Z5UEl1fb.png",_="/assets/-175075601713328-BgKafXGj.png",b="/assets/-175075601713329-DjlaVcvl.png",h="/assets/-175075601713330-DOOw-Q0K.png",B="/assets/-175075601713431-Cr5s9ofI.png",C="/assets/image-20250624170754293-3CprS5JB.png",L="/assets/-175075601713328-BgKafXGj.png",S="/assets/-175075610488551-CvGNyHn8.png",f="/assets/-175075610488552-rQyNno7s.png",w="/assets/-175075610488553-DDup2Nf5.png",y="/assets/-175075610488654-DzjyUMpw.png",I="/assets/-175075610488655-DhVBri2B.png",R="/assets/-175075614158561-CaodaHfP.png",x="/assets/-175075614158562-DuNmpKrt.png",N="/assets/-175075614158563-zdI_s6d1.png",D="/assets/-175075614158564-qVBIBZrI.png",F="/assets/-175075614158565-DzrO3_Wt.png",j="/assets/-175075615262571-NHPP0Sp2.png",M="/assets/-175075615262672-O7yQW-dv.png",O="/assets/-175075615262673-ClDcmudf.png",P="/assets/-175075615262674-oMBMts9M.png",H={};function q(E,n){return c(),a("div",null,n[0]||(n[0]=[e('<p><img src="https://bizhi1.com/wp-content/uploads/2024/11/marvel-jean-grey-comics-x-men-desktop-wallpaper.jpg" alt="漫画人物 凤凰桌面壁纸"></p><div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>1 负载均衡原理</p><p>2 NacosRule</p></div><p>我们知道微服务间远程调用都是有OpenFeign帮我们完成的，甚至帮我们实现了服务列表之间的负载均衡。但具体负载均衡的规则是什么呢？何时做的负载均衡呢？</p><p>接下来我们一起来分析一下。</p><h2 id="_1-负载均衡原理" tabindex="-1"><a class="header-anchor" href="#_1-负载均衡原理"><span>1 负载均衡原理</span></a></h2><p>在SpringCloud的早期版本中，负载均衡都是有Netflix公司开源的Ribbon组件来实现的，甚至Ribbon被直接集成到了Eureka-client和Nacos-Discovery中。</p><p>但是自SpringCloud2020版本开始，已经弃用Ribbon，改用Spring自己开源的Spring Cloud LoadBalancer了，我们使用的OpenFeign的也已经与其整合。</p><p>接下来我们就通过源码分析，来看看OpenFeign底层是如何实现负载均衡功能的。</p><h3 id="_1-1-源码跟踪" tabindex="-1"><a class="header-anchor" href="#_1-1-源码跟踪"><span>1.1 源码跟踪</span></a></h3><p>要弄清楚OpenFeign的负载均衡原理，最佳的办法肯定是从FeignClient的请求流程入手。</p><p>首先，我们在<code>com.hmall.cart.service.impl.CartServiceImpl</code>中的<code>queryMyCarts</code>方法中打一个断点。然后在swagger页面请求购物车列表接口。</p><p>进入断点后，观察<code>ItemClient</code>这个接口：</p><p><img src="'+p+'" alt="img"></p><p>你会发现ItemClient是一个代理对象，而代理的处理器则是<code>SentinelInvocationHandler</code>。这是因为我们项目中引入了<code>Sentinel</code>导致。</p><p>我们进入<code>SentinelInvocationHandler</code>类中的<code>invoke</code>方法看看：</p><p><img src="'+o+'" alt="img"></p><p>可以看到这里是先获取被代理的方法的处理器<code>MethodHandler</code>，接着，Sentinel就会开启对簇点资源的监控：</p><p><img src="'+t+'" alt="img"></p><p>开启Sentinel的簇点资源监控后，就可以调用处理器了，我们尝试跟入，会发现有两种实现：</p><p><img src="'+i+'" alt="img"></p><p>这其实就是OpenFeign远程调用的处理器了。继续跟入会进入<code>SynchronousMethodHandler</code>这个实现类：</p><p><img src="'+l+'" alt="img"></p><p>在上述方法中，会循环尝试调用<code>executeAndDecode()</code>方法，直到成功或者是重试次数达到Retryer中配置的上限。</p><p>我们继续跟入<code>executeAndDecode()</code>方法：</p><p><img src="'+r+'" alt="img"></p><p><code>executeAndDecode()</code>方法最终会利用<code>client</code>去调用<code>execute()</code>方法，发起远程调用。</p><p>这里的client的类型是<code>feign.Client</code>接口，其下有很多实现类：</p><p><img src="'+d+'" alt="img"></p><p>由于我们项目中整合了seata，所以这里client对象的类型是<code>SeataFeignBlockingLoadBalancerClient</code>，内部实现如下：</p><p><img src="'+u+'" alt="img"></p><p>这里直接调用了其父类，也就是<code>FeignBlockingLoadBalancerClient</code>的<code>execute</code>方法，来看一下：</p><p><img src="'+m+'" alt="img"></p><p>整段代码中核心的有4步：</p><ul><li>从请求的<code>URI</code>中找出<code>serviceId</code></li><li>利用<code>loadBalancerClient</code>，根据<code>serviceId</code>做负载均衡，选出一个实例<code>ServiceInstance</code></li><li>用选中的<code>ServiceInstance</code>的<code>ip</code>和<code>port</code>替代<code>serviceId</code>，重构<code>URI</code></li><li>向真正的URI发送请求</li></ul><p>所以负载均衡的关键就是这里的loadBalancerClient，类型是<code>org.springframework.cloud.client.loadbalancer.LoadBalancerClient</code>，这是<code>Spring-Cloud-Common</code>模块中定义的接口，只有一个实现类：</p><p><img src="'+g+'" alt="img"></p><p>而这里的<code>org.springframework.cloud.client.loadbalancer.BlockingLoadBalancerClient</code>正是<code>Spring-Cloud-LoadBalancer</code>模块下的一个类：</p><p><img src="'+k+'" alt="img"></p><p>我们继续跟入其<code>BlockingLoadBalancerClient#choose()</code>方法：</p><p><img src="'+v+'" alt="img"></p><p>图中代码的核心逻辑如下：</p><ul><li>根据serviceId找到这个服务采用的负载均衡器（<code>ReactiveLoadBalancer</code>），也就是说我们可以给每个服务配不同的负载均衡算法。</li><li>利用负载均衡器（<code>ReactiveLoadBalancer</code>）中的负载均衡算法，选出一个服务实例</li></ul><p><code>ReactiveLoadBalancer</code>是<code>Spring-Cloud-Common</code>组件中定义的负载均衡器接口规范，而<code>Spring-Cloud-Loadbalancer</code>组件给出了两个实现：</p><p><img src="'+_+'" alt="img"></p><p>默认的实现是<code>RoundRobinLoadBalancer</code>，即<strong>轮询</strong>负载均衡器。负载均衡器的核心逻辑如下：</p><p><img src="'+b+'" alt="img"></p><p>核心流程就是两步：</p><ul><li>利用<code>ServiceInstanceListSupplier#get()</code>方法拉取服务的实例列表，这一步是采用响应式编程</li><li>利用本类，也就是<code>RoundRobinLoadBalancer</code>的<code>getInstanceResponse()</code>方法挑选一个实例，这里采用了轮询算法来挑选。</li></ul><p>这里的ServiceInstanceListSupplier有很多实现：</p><p><img src="'+h+'" alt="img"></p><p>其中CachingServiceInstanceListSupplier采用了装饰模式，加了服务实例列表缓存，避免每次都要去注册中心拉取服务实例列表。而其内部是基于<code>DiscoveryClientServiceInstanceListSupplier</code>来实现的。</p><p>在这个类的构造函数中，就会异步的基于DiscoveryClient去拉取服务的实例列表：</p><p><img src="'+B+'" alt="img"></p><h3 id="_1-2-流程梳理" tabindex="-1"><a class="header-anchor" href="#_1-2-流程梳理"><span>1.2 流程梳理</span></a></h3><p>根据之前的分析，我们会发现Spring在整合OpenFeign的时候，实现了<code>org.springframework.cloud.openfeign.loadbalancer.FeignBlockingLoadBalancerClient</code>类，其中定义了OpenFeign发起远程调用的核心流程。也就是四步：</p><ul><li>获取请求中的<code>serviceId</code></li><li>根据<code>serviceId</code>负载均衡，找出一个可用的服务实例</li><li>利用服务实例的<code>ip</code>和<code>port</code>信息重构url</li><li>向真正的url发起请求</li></ul><p>而具体的负载均衡则是不是由<code>OpenFeign</code>组件负责。而是分成了<strong>负载均衡的接口规范</strong>，以及<strong>负载均衡的具体实现</strong>两部分。</p><p>负载均衡的接口规范是定义在<code>Spring-Cloud-Common</code>模块中，包含下面的接口：</p><ul><li><code>LoadBalancerClient</code>：负载均衡客户端，职责是根据serviceId最终负载均衡，选出一个服务实例</li><li><code>ReactiveLoadBalancer</code>：负载均衡器，负责具体的负载均衡算法</li></ul><p>OpenFeign的负载均衡是基于<code>Spring-Cloud-Common</code>模块中的负载均衡规则接口，并没有写死具体实现。这就意味着以后还可以拓展其它各种负载均衡的实现。</p><p>不过目前<code>SpringCloud</code>中只有<code>Spring-Cloud-Loadbalancer</code>这一种实现。</p><p><code>Spring-Cloud-Loadbalancer</code>模块中，实现了<code>Spring-Cloud-Common</code>模块的相关接口，具体如下：</p><ul><li><code>BlockingLoadBalancerClient</code>：实现了<code>LoadBalancerClient</code>，会根据serviceId选出负载均衡器并调用其算法实现负载均衡。</li><li><code>RoundRobinLoadBalancer</code>：基于轮询算法实现了<code>ReactiveLoadBalancer</code></li><li><code>RandomLoadBalancer</code>：基于随机算法实现了<code>ReactiveLoadBalancer</code>，</li></ul><p>这样一来，整体思路就非常清楚了，流程图如下：</p><p><img src="'+C+'" alt="image-20250624170754293"></p><h2 id="_2-nacosrule" tabindex="-1"><a class="header-anchor" href="#_2-nacosrule"><span>2 NacosRule</span></a></h2><p>之前分析源码的时候我们发现负载均衡的算法是有<code>ReactiveLoadBalancer</code>来定义的，我们发现它的实现类有三个：</p><p><img src="'+L+'" alt="img"></p><p>其中<code>RoundRobinLoadBalancer</code>和<code>RandomLoadBalancer</code>是由<code>Spring-Cloud-Loadbalancer</code>模块提供的，而<code>NacosLoadBalancer</code>则是由<code>Nacos-Discorvery</code>模块提供的。</p><p>默认采用的负载均衡策略是<code>RoundRobinLoadBalancer</code>，那如果我们要切换负载均衡策略该怎么办？</p><h3 id="_2-1-修改负载均衡策" tabindex="-1"><a class="header-anchor" href="#_2-1-修改负载均衡策"><span>2.1 修改负载均衡策</span></a></h3><p>查看源码会发现，<code>Spring-Cloud-Loadbalancer</code>模块中有一个自动配置类：</p><p><img src="'+S+'" alt="img"></p><p>其中定义了默认的负载均衡器：</p><p><img src="'+f+'" alt="img"></p><p>这个Bean上添加了<code>@ConditionalOnMissingBean</code>注解，也就是说如果我们自定义了这个类型的bean，则负载均衡的策略就会被改变。</p><p>我们在<code>hm-cart</code>模块中的添加一个配置类：</p><p><img src="'+w+`" alt="img"></p><p>代码如下：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>hmall<span class="token punctuation">.</span>cart<span class="token punctuation">.</span>config</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>nacos<span class="token punctuation">.</span></span><span class="token class-name">NacosDiscoveryProperties</span></span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>nacos<span class="token punctuation">.</span>loadbalancer<span class="token punctuation">.</span></span><span class="token class-name">NacosLoadBalancer</span></span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>client<span class="token punctuation">.</span></span><span class="token class-name">ServiceInstance</span></span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>loadbalancer<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">ReactorLoadBalancer</span></span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>loadbalancer<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">ServiceInstanceListSupplier</span></span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>loadbalancer<span class="token punctuation">.</span>support<span class="token punctuation">.</span></span><span class="token class-name">LoadBalancerClientFactory</span></span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Bean</span></span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token punctuation">.</span>env<span class="token punctuation">.</span></span><span class="token class-name">Environment</span></span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OpenFeignConfig</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@Bean</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">ReactorLoadBalancer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ServiceInstance</span><span class="token punctuation">&gt;</span></span> <span class="token function">reactorServiceInstanceLoadBalancer</span><span class="token punctuation">(</span></span>
<span class="line">            <span class="token class-name">Environment</span> environment<span class="token punctuation">,</span> <span class="token class-name">NacosDiscoveryProperties</span> properties<span class="token punctuation">,</span></span>
<span class="line">            <span class="token class-name">LoadBalancerClientFactory</span> loadBalancerClientFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">String</span> name <span class="token operator">=</span> environment<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token class-name">LoadBalancerClientFactory</span><span class="token punctuation">.</span><span class="token constant">PROPERTY_NAME</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">NacosLoadBalancer</span><span class="token punctuation">(</span></span>
<span class="line">                loadBalancerClientFactory<span class="token punctuation">.</span><span class="token function">getLazyProvider</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token class-name">ServiceInstanceListSupplier</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> properties<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong>：</p><p>这个配置类千万不要加<code>@Configuration</code>注解，也不要被SpringBootApplication扫描到。</p><p>由于这个OpenFeignConfig没有加<code>@Configuration</code>注解，也就没有被Spring加载，因此是不会生效的。接下来，我们要在启动类上通过注解来声明这个配置。</p><p>有两种做法：</p><ul><li>全局配置：对所有服务生效</li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@LoadBalancerClients</span><span class="token punctuation">(</span>defaultConfiguration <span class="token operator">=</span> <span class="token class-name">OpenFeignConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>局部配置：只对某个服务生效</li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@LoadBalancerClients</span><span class="token punctuation">(</span><span class="token punctuation">{</span></span>
<span class="line">        <span class="token annotation punctuation">@LoadBalancerClient</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;item-service&quot;</span><span class="token punctuation">,</span> configuration <span class="token operator">=</span> <span class="token class-name">OpenFeignConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们选择全局配置：</p><p><img src="`+y+'" alt="img"></p><p>DEBUG重启后测试，会发现负载均衡器的类型确实切换成功：</p><p><img src="'+I+'" alt="img"></p><h3 id="_2-2-集群优先" tabindex="-1"><a class="header-anchor" href="#_2-2-集群优先"><span>2.2 集群优先</span></a></h3><p><code>RoundRobinLoadBalancer</code>是轮询算法，<code>RandomLoadBalancer</code>是随机算法，那么<code>NacosLoadBalancer</code>是什么负载均衡算法呢？</p><p>我们通过源码来分析一下，先看第一部分：</p><p><img src="'+R+'" alt="img"></p><p>这部分代码的大概流程如下：</p><ul><li>通过<code>ServiceInstanceListSupplier</code>获取服务实例列表</li><li>获取<code>NacosDiscoveryProperties</code>中的<code>clusterName</code>，也就是yml文件中的配置，代表当前服务实例所在集群信息（参考<code>2.2</code>小节，分级模型）</li><li>然后利用stream的filter过滤找到被调用的服务实例中与当前服务实例<code>clusterName</code>一致的。简单来说就是<strong>服务调用者与服务提供者要在一个集群</strong></li></ul><p>为什么？</p><p>假如我现在有两个机房，都部署有<code>item-service</code>和<code>cart-service</code>服务：</p><p><img src="'+x+'" alt="img"></p><p>假如这些服务实例全部都注册到了同一个Nacos。现在，杭州机房的<code>cart-service</code>要调用<code>item-service</code>，会拉取到所有机房的item-service的实例。调用时会出现两种情况：</p><ul><li>直接调用当前机房的<code>item-service</code></li><li>调用其它机房的<code>item-service</code></li></ul><p>本机房调用几乎没有网络延迟，速度比较快。而跨机房调用，如果两个机房相距很远，会存在较大的网络延迟。因此，我们应该尽可能避免跨机房调用，优先本地集群调用：</p><p><img src="'+N+'" alt="img"></p><p>现在的情况是这样的：</p><ul><li><code>cart-service</code>所在集群是<code>default</code></li><li><code>item-service</code>的8081、8083所在集群的<code>default</code></li><li><code>item-service</code>的8084所在集群是<code>BJ</code></li></ul><p><code>cart-service</code>访问<code>item-service</code>时，应该优先访问8081和8082，我们重启<code>cart-service</code>，测试一下：</p><p><img src="'+D+'" alt="img"></p><p>可以看到原本是3个实例，经过筛选后还剩下2个实例。</p><p>查看Debug控制台：</p><p><img src="'+F+'" alt="img"></p><p>同集群的实例还剩下两个，接下来就需要做负载均衡了，具体用的是什么算法呢？</p><h3 id="_2-3-权重配置" tabindex="-1"><a class="header-anchor" href="#_2-3-权重配置"><span>2.3 权重配置</span></a></h3><p>我们继续跟踪<code>NacosLoadBalancer</code>源码：</p><p><img src="'+j+'" alt="img"></p><p>那么问题来了， 这个权重是怎么配的呢？</p><p>我们打开nacos控制台，进入<code>item-service</code>的服务详情页，可以看到每个实例后面都有一个<strong>编辑</strong>按钮：</p><p><img src="'+M+'" alt="img"></p><p>点击，可以看到一个编辑表单：</p><p><img src="'+O+'" alt="img"></p><p>我们将这里的权重修改为5：</p><p><img src="'+P+'" alt="img"></p><p>访问10次购物车接口，可以发现大多数请求都访问到了8083这个实例。</p>',124)]))}const A=s(H,[["render",q]]),K=JSON.parse('{"path":"/docs/Java/Heima/Microservices/Day11_MicroservicesInterview/3-MicroservicesInterview.html","title":"远程调用","lang":"en-US","frontmatter":{"title":"远程调用","date":"2025/03/06"},"headers":[{"level":2,"title":"1 负载均衡原理","slug":"_1-负载均衡原理","link":"#_1-负载均衡原理","children":[{"level":3,"title":"1.1 源码跟踪","slug":"_1-1-源码跟踪","link":"#_1-1-源码跟踪","children":[]},{"level":3,"title":"1.2 流程梳理","slug":"_1-2-流程梳理","link":"#_1-2-流程梳理","children":[]}]},{"level":2,"title":"2 NacosRule","slug":"_2-nacosrule","link":"#_2-nacosrule","children":[{"level":3,"title":"2.1 修改负载均衡策","slug":"_2-1-修改负载均衡策","link":"#_2-1-修改负载均衡策","children":[]},{"level":3,"title":"2.2 集群优先","slug":"_2-2-集群优先","link":"#_2-2-集群优先","children":[]},{"level":3,"title":"2.3 权重配置","slug":"_2-3-权重配置","link":"#_2-3-权重配置","children":[]}]}],"filePathRelative":"docs/Java/Heima/Microservices/Day11_MicroservicesInterview/3-MicroservicesInterview.md","git":{"createdTime":1741251281000,"updatedTime":1750756522000,"contributors":[{"name":"lixuan","email":"2789968443@qq.com","commits":2}]}}');export{A as comp,K as data};
