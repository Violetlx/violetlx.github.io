import{_ as p,c as l,b as n,a,d as e,e as i,r as c,o}from"./app-B_5tQx1u.js";const m="/assets/image-20211005234314353-B-kX9kd7.png",r="/assets/image-20211005235147225-uEKZ10Pe.png",g="/assets/image-20211005235318495-DHNHDcDw.png",u="/assets/image-20211006000020722-KGwuvsiJ.png",h="/assets/image-20211006001543760-BEccKAKm.png",d="/assets/image-20211006002256130-C5nPrzTx.png",k="/assets/image-20211006104100665-MOjjK2Jn.png",v="/assets/image-20211006104300688-N2Fg4NAK.png",b="/assets/image-20211006104345548-Bo5I0hhP.png",y="/assets/image-20211006114715921-C-hEpGHE.png",x="/assets/image-20211006114938467-CKKQDOwb.png",_="/assets/image-20211006115017927-EGFinwdt.png",w="/assets/image-20211006115845659-DZ-jdmeF.png",f="/assets/image-20230611013038646-CmOCJcyf.png",q="/assets/image-20230611013111430-DNZ99p8c.png",S="/assets/image-20230611013124906-C0Bh4kDd.png",z="/assets/image-20230611020641931-zX6J3w7z.png",M="/assets/image-20211006133617102-DlQ3SRl_.png",T="/assets/image-20211006134000106-CwFf9vpU.png",B="/assets/image-20211006134309470-koGQogAP.png",L="/assets/image-20211006134504824-CQWRZP0f.png",P="/assets/image-20211006135804099-5ANMvA_i.png",C="/assets/image-20211006140410310-DKP5qfZS.png",D="/assets/image-20211006140428742-DamMBxA1.png",N={},A={href:"https://zhuanlan.zhihu.com/p/476335458",target:"_blank",rel:"noopener noreferrer"};function E(R,s){const t=c("ExternalLinkIcon");return o(),l("div",null,[s[5]||(s[5]=n('<p><img src="https://artfiles.alphacoders.com/119/thumb-1920-119222.png" alt="Download Minimalist Headband Black Dress Dress Short Hair Blindfold White Hair YoRHa No.2 Type B Video Game NieR: Automata Minimalist Gaming Art"></p><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h2><ul><li><p>树的定义</p><p><img src="'+m+'" alt="images/6-Structure/image-20211005234314353.png"></p></li><li><p>树的基本术语</p><blockquote><ul><li>一个结点拥有的子树称为该结点的度(Degree)</li><li>树中结点最大的度为该树的度</li><li>度数为零的结点为叶子(Left)</li><li>该结点的子结点称为双亲或父结点</li><li>树中最大的层级为树的深度(高度)</li><li>森林(没有根结点的树)</li></ul></blockquote></li><li><p>树的抽象数据类型</p><blockquote><p><img src="'+r+'" alt="image-20211005235147225"></p><p><img src="'+g+'" alt="image-20211005235318495"></p></blockquote></li></ul><p><strong>树的存储结构</strong></p><blockquote><p>双亲表示法(子结点存储父结点指针)</p><p>孩子表示法(把每个结点孩子指针用链表存储起来)</p><p><img src="'+u+'" alt="images/6-Structure/image-20211006000020722.png"></p><p>孩子兄弟表示法(二叉树实现)</p><p>data | firstChild | rigthChild</p><p>firstChild 存储第一个孩子结点指针</p><p>rigth 存储该结点右兄弟结点指针</p><p><img src="'+h+'" alt="image-20211006001543760"></p></blockquote><h2 id="二叉树-binary-tree" tabindex="-1"><a class="header-anchor" href="#二叉树-binary-tree"><span>二叉树(Binary Tree)</span></a></h2><blockquote><p><img src="'+d+'" alt="image-20211006002256130"></p><p><strong>二叉树不存在结点大于2的度</strong></p></blockquote><p><strong>二叉树性质</strong></p><blockquote><ol><li>在二叉树的第i层最多有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>个结点(i&gt;=1)</li><li>深度为k的二叉树至多有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>个结点</li><li>存在任意二叉树T,其叶子结点数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,度为2的结点数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_0=n_2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li><li>具有n个结点的__完全二叉树__的深度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\\log_2n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9386em;vertical-align:-0.2441em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li></ol></blockquote><p><strong>二叉树的存储结构</strong></p><blockquote><ul><li><p>顺序存储结构</p><p><img src="'+k+'" alt="image-20211006104100665"></p></li><li><p>二叉链表</p><p><img src="'+v+'" alt="image-20211006104300688"></p><p><img src="'+b+`" alt="image-20211006104345548"></p></li></ul></blockquote><p><strong>遍历二叉树</strong></p><ul><li><p><strong>前序遍历</strong></p><blockquote><p>访问根结点-&gt;前序遍历左子树-&gt;前序遍历右子树</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line">T<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span></span>
<span class="line"><span class="token function">PreOrderTraveres</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote></li><li><p><strong>中序遍历</strong></p><blockquote><p>中序遍历左子树-&gt;访问根结点-&gt;中序遍历右子树</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token function">PreOrderTraveres</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">T<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span></span>
<span class="line"><span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote></li><li><p><strong>后序遍历</strong></p><blockquote><p>后序遍历左子树-&gt;后序遍历右子树-&gt;访问根结点</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token function">PreOrderTraveres</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">T<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote></li></ul><p>非递归遍历算法</p><blockquote><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">void</span> <span class="token function">Inorder</span><span class="token punctuation">(</span>BinTree bt<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">SeqStack S<span class="token punctuation">;</span> BInTNode <span class="token operator">*</span>p<span class="token punctuation">;</span></span>
<span class="line"><span class="token function">InitStack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span>bt<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">GetTop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token function">Push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span><span class="token function">GetTop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  p<span class="token operator">=</span><span class="token function">Pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">      <span class="token function">GetTop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      p <span class="token operator">=</span> <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token function">Push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span>p<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>已知<strong>前序遍历序列和中序遍历序列</strong>,可以确定唯一一个二叉树</p><p>已知<strong>后序遍历和中序遍历序列</strong>,可以确定唯一一个二叉树</p></blockquote><h2 id="线索二叉树-解决空间利用问题" tabindex="-1"><a class="header-anchor" href="#线索二叉树-解决空间利用问题"><span>线索二叉树(解决空间利用问题)</span></a></h2><p><em>指向前驱和后继的指针称为线索,加上线索的二叉树链表称为线索链表</em></p><p>使用中序遍历出序列将对应的空指针域指向前驱和后继</p><p>__H D I B J E A F C G __ 中序遍历</p><p><img src="`+y+'" alt="images/6-Structure/image-20211006114715921.png"></p><p><img src="'+x+'" alt="image-20211006114938467"></p><p><img src="'+_+'" alt="image-20211006115017927"></p><p><img src="'+w+'" alt="image-20211006115845659"></p><h2 id="查找树" tabindex="-1"><a class="header-anchor" href="#查找树"><span><strong>查找树</strong></span></a></h2><p><strong>BST：二叉排序树</strong></p><ul><li>左结点值小于父结点，右结点值大于父结点</li><li>极小值：二叉树最左端的结点（<strong>叶结点或者只包含一个子结点的父结点</strong>）</li><li>极大值：二叉树最右端的结点（<strong>叶结点或者只包含一个子结点的父结点</strong>）</li><li>插入：<strong>新插入的结点一定是个叶子结点</strong>（存在相同值不插入）</li><li>删除 <ol><li>叶子结点：直接删除</li><li>非叶子结点 <ul><li>只包含一个子结点的，使用子结点代替删除结点</li><li>包含左右子结点的，中序遍历后找到删除结点<strong>前序元素</strong>或<strong>后序元素</strong>代替被删除的结点</li></ul></li></ol></li></ul><p><strong>AVL：平衡二叉树（解决BST退化成线性表问题）</strong></p><ul><li><p>|BF|&lt;=1 的二叉排序树（BF：平衡因子，同层左树深度减去右树深度）</p></li><li><p>插入：插入的父结点不可能失衡，<strong>其祖父结点可能存在失衡情况</strong></p><blockquote><p>失衡调节操作</p><ol><li>LL： 左失衡（最大层失衡点左侧路径）执行右旋操作</li><li>RR：右失衡，执行左旋操作</li><li>RL：右左失衡（最大层失衡点到新增结点路径）：右旋转为RR，在进行左旋恢复平衡</li><li>LR：左右失衡，先左旋，后右旋</li></ol><p><strong>右旋操作步骤：</strong></p><ul><li><p>失衡点的左子结点代替失衡点</p></li><li><p>左子结点的右结点使用失衡点代替</p></li><li><p>原先右子结点作为失衡结点的左子结点</p><p><img src="'+f+'" alt="image-20230611013038646"></p><p><img src="'+q+'" alt="image-20230611013111430"></p><p><img src="'+S+'" alt="image-20230611013124906"></p></li></ul></blockquote></li></ul><p><strong>B树：多路查找树</strong></p>',29)),a("ul",null,[s[3]||(s[3]=n('<li><p><strong>每个结点至少存在两个子结点</strong></p></li><li><p>每个结点存储的数据份数等于其度数减一</p></li><li><p><strong>每个结点中存储数据从小到大排序</strong></p></li><li><p><strong>所有叶子结点都在同一层</strong></p></li><li><p>2-3树 ：结点最大度为3的B树</p><blockquote><p><img src="'+z+'" alt="image-20230611020641931"></p></blockquote></li><li><p>2-3-4树：自平衡树（非叶子结点最大度为4的B树）</p><blockquote><p>插入：叶子结点插入</p><ul><li>升元：将插入结点有2升级为3，或由3升级到4结点</li><li>选元：将中间元素提升到父结点（递归）</li></ul></blockquote></li>',6)),a("li",null,[s[2]||(s[2]=a("p",null,"红黑树：(使用AVL与红黑颜色实现2-3-4树，接近AVL树)",-1)),a("blockquote",null,[s[1]||(s[1]=n('<ol><li>根结点黑色</li><li><strong>叶子结点不存储数据，且颜色为黑色</strong></li><li><strong>子结点与父结点颜色相反（每个红结点下面都是黑结点）</strong></li><li>从根结点到任意叶子结点经过的黑色路径相等</li><li>红黑树最大高度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2log_2(n+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ol><p><strong>红黑树转2-3-4树</strong>：将所有红色结点移动到其父类上，则构成2-3-4树，</p><p><strong>2-3-4树转红黑树</strong>：</p><ul><li>4结点拆分1个黑色结点和两个红色结点(中间对应黑色结点)</li><li>3结点拆分1个黑色结点和1个红色结点，先插入的键对应节点为黑色</li><li>2结点全部转为黑色结点</li></ul><p>插入：新加入结点为红色</p><ol><li>若父结点为黑色，无需调整（平衡状态）</li><li>父结点和叔节点为红色，向上判断其祖父结点</li><li>父结点为红色，叔节点为黑色，最多两次旋转恢复平衡</li></ol>',6)),a("p",null,[a("a",A,[s[0]||(s[0]=e("删除")),i(t)])])])]),s[4]||(s[4]=a("li",null,[a("p",null,[a("strong",null,"B+树：")]),a("blockquote",null,[a("p",null,"叶子结点包含所有的数据，且排序")])],-1))]),s[6]||(s[6]=n('<h2 id="树与森林与二叉树转换" tabindex="-1"><a class="header-anchor" href="#树与森林与二叉树转换"><span>树与森林与二叉树转换</span></a></h2><h3 id="树转二叉树" tabindex="-1"><a class="header-anchor" href="#树转二叉树"><span>树转二叉树</span></a></h3><ol><li>兄弟结点连线</li><li>树中结点只保留与它第一个孩子结点连线(<strong>兄弟结点变成右子结点</strong>)</li></ol><p><img src="'+M+'" alt="image-20211006133617102"></p><h3 id="森林转为二叉树" tabindex="-1"><a class="header-anchor" href="#森林转为二叉树"><span>森林转为二叉树</span></a></h3><ol><li>将森林中每棵树转为二叉树</li><li>第一个二叉树不动,依次把二叉树的根结点作为前一个二叉树根结点的右孩子</li></ol><p><img src="'+T+'" alt="image-20211006134000106"></p><h3 id="二叉树转为树" tabindex="-1"><a class="header-anchor" href="#二叉树转为树"><span>二叉树转为树</span></a></h3><ol><li>将每一层右子结点与父结点相连</li><li>去掉右子结点连线</li></ol><p><img src="'+B+'" alt="image-20211006134309470"></p><h3 id="二叉树转为森林" tabindex="-1"><a class="header-anchor" href="#二叉树转为森林"><span>二叉树转为森林</span></a></h3><p><img src="'+L+'" alt="image-20211006134504824"></p><h2 id="赫夫曼树及其应用" tabindex="-1"><a class="header-anchor" href="#赫夫曼树及其应用"><span>赫夫曼树及其应用</span></a></h2><p>从树中一个结点到另一个结点之间的分支构成两个结点之间的路径,路径上的分支数目称作路径长度.树的路径长度就是从根结点到每个结点路径长度之和</p><p>WPL:<strong>带权路径长度WPL最小的二叉树称为赫夫曼树</strong></p><h3 id="构造赫夫曼树" tabindex="-1"><a class="header-anchor" href="#构造赫夫曼树"><span>构造赫夫曼树</span></a></h3><blockquote><ol><li>将叶子结点顺序排列数列</li><li>取两个最小权值结点构造成一个新结点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">N_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>代入步骤1中数列</li><li>重复1,2步骤</li></ol><p>eg: 存在数列 __A5, E10, B15, D30, C40__构造赫夫曼树</p><p><img src="'+P+'" alt="image-20211006135804099"></p><p>WPL = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>40</mn><mo>×</mo><mn>1</mn><mo>+</mo><mn>30</mn><mo>×</mo><mn>2</mn><mo>+</mo><mn>15</mn><mo>×</mo><mn>3</mn><mo>+</mo><mn>10</mn><mo>×</mo><mn>4</mn><mo>+</mo><mn>5</mn><mo>×</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">40\\times 1 + 30\\times 2+15\\times3+10\\times4+5\\times4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">40</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">30</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">15</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">10</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> = 205</p></blockquote><h3 id="赫夫曼编码" tabindex="-1"><a class="header-anchor" href="#赫夫曼编码"><span>赫夫曼编码</span></a></h3><blockquote><p>构建赫夫曼树,使用0,1字符代替左子树和右子树经过路径,构成编码表</p><p><img src="'+C+'" alt="image-20211006140410310"></p><p><img src="'+D+'" alt="image-20211006140428742"></p></blockquote>',19))])}const O=p(N,[["render",E]]),K=JSON.parse('{"path":"/docs/Computer/Computer/5_Structure/6-Structure.html","title":"树和二叉树","lang":"en-US","frontmatter":{"title":"树和二叉树","date":"2025/07/04"},"headers":[{"level":2,"title":"概述","slug":"概述","link":"#概述","children":[]},{"level":2,"title":"二叉树(Binary Tree)","slug":"二叉树-binary-tree","link":"#二叉树-binary-tree","children":[]},{"level":2,"title":"线索二叉树(解决空间利用问题)","slug":"线索二叉树-解决空间利用问题","link":"#线索二叉树-解决空间利用问题","children":[]},{"level":2,"title":"查找树","slug":"查找树","link":"#查找树","children":[]},{"level":2,"title":"树与森林与二叉树转换","slug":"树与森林与二叉树转换","link":"#树与森林与二叉树转换","children":[{"level":3,"title":"树转二叉树","slug":"树转二叉树","link":"#树转二叉树","children":[]},{"level":3,"title":"森林转为二叉树","slug":"森林转为二叉树","link":"#森林转为二叉树","children":[]},{"level":3,"title":"二叉树转为树","slug":"二叉树转为树","link":"#二叉树转为树","children":[]},{"level":3,"title":"二叉树转为森林","slug":"二叉树转为森林","link":"#二叉树转为森林","children":[]}]},{"level":2,"title":"赫夫曼树及其应用","slug":"赫夫曼树及其应用","link":"#赫夫曼树及其应用","children":[{"level":3,"title":"构造赫夫曼树","slug":"构造赫夫曼树","link":"#构造赫夫曼树","children":[]},{"level":3,"title":"赫夫曼编码","slug":"赫夫曼编码","link":"#赫夫曼编码","children":[]}]}],"filePathRelative":"docs/Computer/Computer/5_Structure/6-Structure.md","git":{"createdTime":1751621258000,"updatedTime":1751621258000,"contributors":[{"name":"lixuan","email":"2789968443@qq.com","commits":1}]}}');export{O as comp,K as data};
