import{_ as t,c as i,b as a,a as n,d as e,e as l,r as c,o}from"./app-CezBFXHK.js";const r="/assets/image-20250310165228781-DeHgAlaD.png",d="/assets/image-20250310165325138-DoFPmC_v.png",u="/assets/image-20250311094500269-DNEfVc6I.png",m="/assets/image-20250311094529757-nwQ-gokS.png",g="/assets/image-20250311094547034-T8krHJx6.png",v="/assets/image-20250311094607429-BrQfmOQn.png",k="/assets/image-20250311094708133-QckKU1IT.png",h="/assets/image-20250311095303173-vnGmijI3.png",_="/assets/image-20250311095337383-vPN6NJhB.png",b="/assets/image-20250311095350419-BdbRumvx.png",x="/assets/image-20250311095402162-D8ZIQO-w.png",y="/assets/image-20250311095408388-BkF89Y8a.png",f="/assets/image-20250311100417273-BmYilQ8Z.png",N="/assets/image-20250311100431652-CEdbxL--.png",E="/assets/image-20250311100440920-Diis5Aab.png",I={},B={href:"http://192.168.150.101:8848/nacos/%EF%BC%8C%E6%B3%A8%E6%84%8F%E5%B0%86%60192.168.150.101%60%E6%9B%BF%E6%8D%A2%E4%B8%BA%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BAIP%E5%9C%B0%E5%9D%80%E3%80%82",target:"_blank",rel:"noopener noreferrer"};function w(C,s){const p=c("ExternalLinkIcon");return o(),i("div",null,[s[2]||(s[2]=a('<p><img src="https://bizhi1.com/wp-content/uploads/2025/01/Snow_Winter_House_Dark_Forest_Lake_Louise_Winter_5K-Wallpaper_3840x2160.jpg" alt="雪 冬季房屋 黑暗森林 路易斯湖 冬季房屋"></p><div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>1 注册中心原理</p><p>2 Nacos 注册中心</p><p>3 服务注册</p><p>4 服务发现</p></div><p>在上一章我们实现了微服务拆分，并且通过Http请求实现了跨微服务的远程调用。不过这种手动发送Http请求的方式存在一些问题。</p><p>试想一下，假如商品微服务被调用较多，为了应对更高的并发，我们进行了多实例部署，如图：</p><p><img src="'+r+'" alt="image-20250310165228781"></p><p>此时，每个<code>item-service</code>的实例其IP或端口不同，问题来了：</p><ul><li>item-service这么多实例，cart-service如何知道每一个实例的地址？</li><li>http请求要写url地址，<code>cart-service</code>服务到底该调用哪个实例呢？</li><li>如果在运行过程中，某一个<code>item-service</code>实例宕机，<code>cart-service</code>依然在调用该怎么办？</li><li>如果并发太高，<code>item-service</code>临时多部署了N台实例，<code>cart-service</code>如何知道新实例的地址？</li></ul><p>为了解决上述问题，就必须引入注册中心的概念了，接下来我们就一起来分析下注册中心的原理。</p><h2 id="_1-注册中心原理" tabindex="-1"><a class="header-anchor" href="#_1-注册中心原理"><span>1 注册中心原理</span></a></h2><p>在微服务远程调用的过程中，包括两个角色：</p><ul><li>服务提供者：提供接口供其它微服务访问，比如<code>item-service</code></li><li>服务消费者：调用其它微服务提供的接口，比如<code>cart-service</code></li></ul><p>在大型微服务项目中，服务提供者的数量会非常多，为了管理这些服务就引入了<strong>注册中心</strong>的概念。注册中心、服务提供者、服务消费者三者间关系如下：</p><p><img src="'+d+'" alt="image-20250310165325138"></p><p>流程如下：</p><ul><li>服务启动时就会注册自己的服务信息（服务名、IP、端口）到注册中心</li><li>调用者可以从注册中心订阅想要的服务，获取服务对应的实例列表（1个服务可能多实例部署）</li><li>调用者自己对实例列表负载均衡，挑选一个实例</li><li>调用者向该实例发起远程调用</li></ul><p>当服务提供者的实例宕机或者启动新实例时，调用者如何得知呢？</p><ul><li>服务提供者会定期向注册中心发送请求，报告自己的健康状态（心跳请求）</li><li>当注册中心长时间收不到提供者的心跳时，会认为该实例宕机，将其从服务的实例列表中剔除</li><li>当服务有新实例启动时，会发送注册服务请求，其信息会被记录在注册中心的服务实例列表</li><li>当注册中心服务列表变更时，会主动通知微服务，更新本地服务列表</li></ul><h2 id="_2-nacos-注册中心" tabindex="-1"><a class="header-anchor" href="#_2-nacos-注册中心"><span>2 Nacos 注册中心</span></a></h2><p>目前开源的注册中心框架有很多，国内比较常见的有：</p><ul><li>Eureka：Netflix公司出品，目前被集成在SpringCloud当中，一般用于Java应用</li><li>Nacos：Alibaba公司出品，目前被集成在SpringCloudAlibaba中，一般用于Java应用</li><li>Consul：HashiCorp公司出品，目前集成在SpringCloud中，不限制微服务语言</li></ul><p>以上几种注册中心都遵循SpringCloud中的API规范，因此在业务开发使用上没有太大差异。由于Nacos是国内产品，中文文档比较丰富，而且同时具备<strong>配置管理</strong>功能（后面会学习），因此在国内使用较多，课堂中我们会Nacos为例来学习。</p><p>官方网站如下：</p><iframe src="https://nacos.io/zh-cn/" style="width:100%;height:60vh;"></iframe><p>我们基于Docker来部署Nacos的注册中心，首先我们要准备MySQL数据库表，用来存储Nacos的数据。由于是Docker部署，所以大家需要将资料中的SQL文件导入到你<strong>Docker中的MySQL容器</strong>中：</p><p><img src="'+u+'" alt="image-20250311094500269"></p><p>最终表结构如下：</p><p><img src="'+m+'" alt="image-20250311094529757"></p><p>然后，找到课前资料下的nacos文件夹：</p><p><img src="'+g+'" alt="image-20250311094547034"></p><p>其中的<code>nacos/custom.env</code>文件中，有一个MYSQL_SERVICE_HOST也就是mysql地址，需要修改为你自己的虚拟机IP地址：</p><p><img src="'+v+`" alt="image-20250311094607429"></p><p>然后，将课前资料中的<code>nacos</code>目录上传至虚拟机的<code>/root</code>目录。</p><p>进入root目录，然后执行下面的docker命令：</p><div class="language-powershell line-numbers-mode" data-highlighter="prismjs" data-ext="powershell" data-title="powershell"><pre><code><span class="line">docker run <span class="token operator">-</span>d \\</span>
<span class="line"><span class="token operator">--</span>name nacos \\</span>
<span class="line"><span class="token operator">--</span>env-file <span class="token punctuation">.</span><span class="token operator">/</span>nacos/custom<span class="token punctuation">.</span>env \\</span>
<span class="line"><span class="token operator">-</span>p 8848:8848 \\</span>
<span class="line"><span class="token operator">-</span>p 9848:9848 \\</span>
<span class="line"><span class="token operator">-</span>p 9849:9849 \\</span>
<span class="line"><span class="token operator">--</span>restart=always \\</span>
<span class="line">nacos/nacos-server:v2<span class="token punctuation">.</span>1<span class="token punctuation">.</span>0-slim</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,34)),n("p",null,[s[1]||(s[1]=e("启动完成后，访问下面地址：")),n("a",B,[s[0]||(s[0]=e("http://192.168.150.101:8848/nacos/，注意将`192.168.150.101`替换为你自己的虚拟机IP地址。")),l(p)])]),s[3]||(s[3]=a('<p>首次访问会跳转到登录页，<strong>账号密码都是nacos</strong></p><p><img src="'+k+`" alt="image-20250311094708133"></p><h2 id="_3-服务注册" tabindex="-1"><a class="header-anchor" href="#_3-服务注册"><span>3 服务注册</span></a></h2><p>接下来，我们把<code>item-service</code>注册到Nacos，步骤如下：</p><ul><li>引入依赖</li><li>配置Nacos地址</li><li>重启</li></ul><h3 id="_3-1-添加依赖" tabindex="-1"><a class="header-anchor" href="#_3-1-添加依赖"><span>3.1 添加依赖</span></a></h3><p>在<code>item-service</code>的<code>pom.xml</code>中添加依赖：</p><div class="language-xml line-numbers-mode" data-highlighter="prismjs" data-ext="xml" data-title="xml"><pre><code><span class="line"><span class="token comment">&lt;!--nacos 服务注册发现--&gt;</span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span></span>
<span class="line">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span></span>
<span class="line">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-2-配置-nacos" tabindex="-1"><a class="header-anchor" href="#_3-2-配置-nacos"><span>3.2 配置 Nacos</span></a></h3><p>在<code>item-service</code>的<code>application.yml</code>中添加nacos地址配置：</p><div class="language-yaml line-numbers-mode" data-highlighter="prismjs" data-ext="yml" data-title="yml"><pre><code><span class="line"><span class="token key atrule">spring</span><span class="token punctuation">:</span></span>
<span class="line">  <span class="token key atrule">application</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token key atrule">name</span><span class="token punctuation">:</span> item<span class="token punctuation">-</span>service <span class="token comment"># 服务名称</span></span>
<span class="line">  <span class="token key atrule">cloud</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token key atrule">nacos</span><span class="token punctuation">:</span></span>
<span class="line">      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> 192.168.150.101<span class="token punctuation">:</span><span class="token number">8848</span> <span class="token comment"># nacos地址</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-3-启动服务实例" tabindex="-1"><a class="header-anchor" href="#_3-3-启动服务实例"><span>3.3 启动服务实例</span></a></h3><p>为了测试一个服务多个实例的情况，我们再配置一个<code>item-service</code>的部署实例：</p><p><img src="`+h+'" alt="image-20250311095303173"></p><p>然后配置启动项，注意重命名并且配置新的端口，避免冲突：</p><p><img src="'+_+'" alt="image-20250311095337383"></p><p>重启<code>item-service</code>的两个实例：</p><p><img src="'+b+'" alt="image-20250311095350419"></p><p>访问nacos控制台，可以发现服务注册成功：</p><p><img src="'+x+'" alt="image-20250311095402162"></p><p>点击详情，可以查看到<code>item-service</code>服务的两个实例信息：</p><p><img src="'+y+`" alt="image-20250311095408388"></p><h2 id="_4-服务发现" tabindex="-1"><a class="header-anchor" href="#_4-服务发现"><span>4 服务发现</span></a></h2><p>服务的消费者要去nacos订阅服务，这个过程就是服务发现，步骤如下：</p><ul><li>引入依赖</li><li>配置Nacos地址</li><li>发现并调用服务</li></ul><h3 id="_4-1-引入依赖" tabindex="-1"><a class="header-anchor" href="#_4-1-引入依赖"><span>4.1 引入依赖</span></a></h3><p>服务发现除了要引入nacos依赖以外，由于还需要负载均衡，因此要引入SpringCloud提供的LoadBalancer依赖。</p><p>我们在<code>cart-service</code>中的<code>pom.xml</code>中添加下面的依赖：</p><div class="language-xml line-numbers-mode" data-highlighter="prismjs" data-ext="xml" data-title="xml"><pre><code><span class="line"><span class="token comment">&lt;!--nacos 服务注册发现--&gt;</span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span></span>
<span class="line">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span></span>
<span class="line">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以发现，这里Nacos的依赖于服务注册时一致，这个依赖中同时包含了服务注册和发现的功能。因为任何一个微服务都可以调用别人，也可以被别人调用，即可以是调用者，也可以是提供者。</p><p>因此，等一会儿<code>cart-service</code>启动，同样会注册到Nacos</p><h3 id="_4-2-配置-nacos-地址" tabindex="-1"><a class="header-anchor" href="#_4-2-配置-nacos-地址"><span>4.2 配置 Nacos 地址</span></a></h3><p>在<code>cart-service</code>的<code>application.yml</code>中添加nacos地址配置：</p><div class="language-yaml line-numbers-mode" data-highlighter="prismjs" data-ext="yml" data-title="yml"><pre><code><span class="line"><span class="token key atrule">spring</span><span class="token punctuation">:</span></span>
<span class="line">  <span class="token key atrule">cloud</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token key atrule">nacos</span><span class="token punctuation">:</span></span>
<span class="line">      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> 192.168.150.101<span class="token punctuation">:</span><span class="token number">8848</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-3-发现并调用服务" tabindex="-1"><a class="header-anchor" href="#_4-3-发现并调用服务"><span>4.3 发现并调用服务</span></a></h3><p>接下来，服务调用者<code>cart-service</code>就可以去订阅<code>item-service</code>服务了。不过item-service有多个实例，而真正发起调用时只需要知道一个实例的地址。</p><p>因此，服务调用者必须利用负载均衡的算法，从多个实例中挑选一个去访问。常见的负载均衡算法有：</p><ul><li>随机</li><li>轮询</li><li>IP的hash</li><li>最近最少访问</li><li>...</li></ul><p>这里我们可以选择最简单的随机负载均衡。</p><p>另外，服务发现需要用到一个工具，DiscoveryClient，SpringCloud已经帮我们自动装配，我们可以直接注入使用：</p><p><img src="`+f+'" alt="image-20250311100417273"></p><p>接下来，我们就可以对原来的远程调用做修改了，之前调用时我们需要写死服务提供者的IP和端口：</p><p><img src="'+N+'" alt="image-20250311100431652"></p><p>但现在不需要了，我们通过DiscoveryClient发现服务实例列表，然后通过负载均衡算法，选择一个实例去调用：</p><p><img src="'+E+'" alt="image-20250311100440920"></p><p>经过swagger测试，发现没有任何问题。</p>',46))])}const S=t(I,[["render",w]]),A=JSON.parse('{"path":"/docs/Java/Heima/Microservices/Day03_Microservices/1_Microservices/4-Microservices.html","title":"服务注册和发现","lang":"en-US","frontmatter":{"title":"服务注册和发现","date":"2025/03/06"},"headers":[{"level":2,"title":"1 注册中心原理","slug":"_1-注册中心原理","link":"#_1-注册中心原理","children":[]},{"level":2,"title":"2 Nacos 注册中心","slug":"_2-nacos-注册中心","link":"#_2-nacos-注册中心","children":[]},{"level":2,"title":"3 服务注册","slug":"_3-服务注册","link":"#_3-服务注册","children":[{"level":3,"title":"3.1 添加依赖","slug":"_3-1-添加依赖","link":"#_3-1-添加依赖","children":[]},{"level":3,"title":"3.2 配置 Nacos","slug":"_3-2-配置-nacos","link":"#_3-2-配置-nacos","children":[]},{"level":3,"title":"3.3 启动服务实例","slug":"_3-3-启动服务实例","link":"#_3-3-启动服务实例","children":[]}]},{"level":2,"title":"4 服务发现","slug":"_4-服务发现","link":"#_4-服务发现","children":[{"level":3,"title":"4.1 引入依赖","slug":"_4-1-引入依赖","link":"#_4-1-引入依赖","children":[]},{"level":3,"title":"4.2 配置 Nacos 地址","slug":"_4-2-配置-nacos-地址","link":"#_4-2-配置-nacos-地址","children":[]},{"level":3,"title":"4.3 发现并调用服务","slug":"_4-3-发现并调用服务","link":"#_4-3-发现并调用服务","children":[]}]}],"filePathRelative":"docs/Java/Heima/Microservices/Day03_Microservices/1_Microservices/4-Microservices.md","git":{"createdTime":1741251281000,"updatedTime":1741753242000,"contributors":[{"name":"lixuan","email":"2789968443@qq.com","commits":3}]}}');export{S as comp,A as data};
