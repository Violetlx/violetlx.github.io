import{_ as s,c as a,b as n,o as c}from"./app-C7pp65Rl.js";const p="/assets/image-20250624170050646--ubkrlKI.png",i="/assets/image-20250624170115731-DH-nbSj-.png",l="/assets/image-20250624170127708-DcVsMwes.png",o="/assets/image-20250624170138805-CHOCN7gh.png",t="/assets/image-20250624170148410-BllViUui.png",r="/assets/image-20250624170159930-DgqsR8eh.png",d="/assets/image-20250624170209325-BE3ri_4W.png",u="/assets/image-20250624170243918-C-8TFQwg.png",m="/assets/image-20250624170252800-BKMQ0m2u.png",k="/assets/image-20250624170308351-BBjoGoFh.png",g="/assets/image-20250624170317875-BDukp5_p.png",v="/assets/image-20250624170355653-HowxjOPs.png",_="/assets/image-20250624170414613-Da93PCoU.png",h="/assets/image-20250624170425530-CJlK4EVH.png",b="/assets/image-20250624170444073-BWgt3UBw.png",E="/assets/image-20250624170459981-D9ToRBeQ.png",N="/assets/image-20250624170529520-8LKfc87O.png",y="/assets/image-20250624170546316-DHig2RN_.png",w="/assets/image-20250624170558292-Cs44mlnP.png",x={};function f(B,e){return c(),a("div",null,e[0]||(e[0]=[n('<p><img src="https://bizhi1.com/wp-content/uploads/2024/11/hogwarts-student-magic-potion-class-desktop-wallpaper.jpg" alt="霍格沃茨学生魔法药水课桌面壁纸"></p><div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>1 环境隔离</p><p>2 分级模型</p><p>3 Eureka</p><p>4 Eureka 和 Nacos 对比</p></div><p>本章主要学习Nacos中的一些特性和原理，以及与Eureka的功能对比。</p><h2 id="_1-环境隔离" tabindex="-1"><a class="header-anchor" href="#_1-环境隔离"><span>1 环境隔离</span></a></h2><p>企业实际开发中，往往会搭建多个运行环境，例如：</p><ul><li>开发环境</li><li>测试环境</li><li>预发布环境</li><li>生产环境</li></ul><p>这些不同环境之间的服务和数据之间需要隔离。</p><p>还有的企业中，会开发多个项目，共享nacos集群。此时，这些项目之间也需要把服务和数据隔离。</p><p>因此，Nacos提供了基于<code>namespace</code>的环境隔离功能。具体的隔离层次如图所示：</p><p><img src="'+p+'" alt="image-20250624170050646"></p><p>说明：</p><ul><li>Nacos中可以配置多个<code>namespace</code>，相互之间完全隔离。默认的<code>namespace</code>名为<code>public</code></li><li><code>namespace</code>下还可以继续分组，也就是group ，相互隔离。 默认的group是<code>DEFAULT_GROUP</code></li><li><code>group</code>之下就是服务和配置了</li></ul><h3 id="_1-1-创建-namespace" tabindex="-1"><a class="header-anchor" href="#_1-1-创建-namespace"><span>1.1 创建 namespace</span></a></h3><p>nacos提供了一个默认的<code>namespace</code>，叫做<code>public</code>：</p><p><img src="'+i+'" alt="image-20250624170115731"></p><p>默认所有的服务和配置都属于这个<code>namespace</code>，当然我们也可以自己创建新的<code>namespace</code>：</p><p><img src="'+l+'" alt="image-20250624170127708"></p><p>然后填写表单：</p><p><img src="'+o+'" alt="image-20250624170138805"></p><p>添加完成后，可以在页面看到我们新建的<code>namespace</code>，并且Nacos为我们自动生成了一个命名空间id：</p><p><img src="'+t+'" alt="image-20250624170148410"></p><p>我们切换到配置列表页，你会发现<code>dev</code>这个命名空间下没有任何配置：</p><p><img src="'+r+'" alt="image-20250624170159930"></p><p>因为之前我们添加的所有配置都在<code>public</code>下：</p><p><img src="'+d+`" alt="image-20250624170209325"></p><h3 id="_1-2-微服务配置-namespace" tabindex="-1"><a class="header-anchor" href="#_1-2-微服务配置-namespace"><span>1.2 微服务配置 namespace</span></a></h3><p>默认情况下，所有的微服务注册发现、配置管理都是走<code>public</code>这个命名空间。如果要指定命名空间则需要修改<code>application.yml</code>文件。</p><p>比如，我们修改<code>item-service</code>服务的bootstrap.yml文件，添加服务发现配置，指定其<code>namespace</code>：</p><div class="language-yaml line-numbers-mode" data-highlighter="prismjs" data-ext="yml" data-title="yml"><pre><code><span class="line"><span class="token key atrule">spring</span><span class="token punctuation">:</span></span>
<span class="line">  <span class="token key atrule">application</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token key atrule">name</span><span class="token punctuation">:</span> item<span class="token punctuation">-</span>service <span class="token comment"># 服务名称</span></span>
<span class="line">  <span class="token key atrule">profiles</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token key atrule">active</span><span class="token punctuation">:</span> dev</span>
<span class="line">  <span class="token key atrule">cloud</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token key atrule">nacos</span><span class="token punctuation">:</span></span>
<span class="line">      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> 192.168.150.101 <span class="token comment"># nacos地址</span></span>
<span class="line">      <span class="token key atrule">discovery</span><span class="token punctuation">:</span> <span class="token comment"># 服务发现配置</span></span>
<span class="line">        <span class="token key atrule">namespace</span><span class="token punctuation">:</span> 8c468c63<span class="token punctuation">-</span>b650<span class="token punctuation">-</span>48da<span class="token punctuation">-</span>a632<span class="token punctuation">-</span>311c75e6d235 <span class="token comment"># 设置namespace，必须用id</span></span>
<span class="line">      <span class="token comment"># 。。。略</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动<code>item-service</code>，查看服务列表，会发现<code>item-service</code>出现在<code>dev</code>下：</p><p><img src="`+u+'" alt="image-20250624170243918"></p><p>而其它服务则出现在<code>public</code>下：</p><p><img src="'+m+'" alt="image-20250624170252800"></p><p>此时访问<code>http://localhost:8082/doc.html</code>，基于<code>swagger</code>做测试：</p><p><img src="'+k+'" alt="image-20250624170308351"></p><p>会发现查询结果中缺少商品的最新价格信息。</p><p>我们查看服务运行日志：</p><p><img src="'+g+'" alt="image-20250624170317875"></p><p>会发现<code>cart-service</code>服务在远程调用<code>item-service</code>时，并没有找到可用的实例。这证明不同namespace之间确实是相互隔离的，不可访问。</p><p>当我们把<code>namespace</code>切换回<code>public</code>，或者统一都是以<code>dev</code>时访问恢复正常。</p><h2 id="_2-分级模型" tabindex="-1"><a class="header-anchor" href="#_2-分级模型"><span>2 分级模型</span></a></h2><p>在一些大型应用中，同一个服务可以部署很多实例。而这些实例可能分布在全国各地的不同机房。由于存在地域差异，网络传输的速度会有很大不同，因此在做服务治理时需要区分不同机房的实例。</p><p>例如item-service，我们可以部署3个实例：</p><ul><li>127.0.0.1:8081</li><li>127.0.0.1:8082</li><li>127.0.0.1:8083</li></ul><p>假如这些实例分布在不同机房，例如：</p><ul><li>127.0.0.1:8081，在上海机房</li><li>127.0.0.1:8082，在上海机房</li><li>127.0.0.1:8083，在杭州机房</li></ul><p>Nacos中提供了集群（<code>cluster</code>）的概念，来对应不同机房。也就是说，一个服务（<code>service</code>）下可以有很多集群（<code>cluster</code>），而一个集群（<code>cluster</code>）中下又可以包含很多实例（<code>instance</code>）。</p><p>如图：</p><p><img src="'+v+'" alt="image-20250624170355653"></p><p>因此，结合我们上一节学习的<code>namespace</code>命名空间的知识，任何一个微服务的实例在注册到Nacos时，都会生成以下几个信息，用来确认当前实例的身份，从外到内依次是：</p><ul><li>namespace：命名空间</li><li>group：分组</li><li>service：服务名</li><li>cluster：集群</li><li>instance：实例，包含ip和端口</li></ul><p>这就是nacos中的服务分级模型。</p><p>在Nacos内部会有一个服务实例的注册表，是基于Map实现的，其结构与分级模型的对应关系如下：</p><p><img src="'+_+'" alt="image-20250624170414613"></p><p>查看nacos控制台，会发现默认情况下所有服务的集群都是default：</p><p><img src="'+h+`" alt="image-20250624170425530"></p><p>如果我们要修改服务所在集群，只需要修改<code>bootstrap.yml</code>即可：</p><div class="language-yaml line-numbers-mode" data-highlighter="prismjs" data-ext="yml" data-title="yml"><pre><code><span class="line"><span class="token key atrule">spring</span><span class="token punctuation">:</span></span>
<span class="line">  <span class="token key atrule">cloud</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token key atrule">nacos</span><span class="token punctuation">:</span></span>
<span class="line">      <span class="token key atrule">discovery</span><span class="token punctuation">:</span></span>
<span class="line">        <span class="token key atrule">cluster-name</span><span class="token punctuation">:</span> BJ <span class="token comment"># 集群名称，自定义</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们修改<code>item-service</code>的<code>bootstrap.yml</code>，然后重新创建一个实例：</p><p><img src="`+b+'" alt="image-20250624170444073"></p><p>再次查看nacos：</p><p><img src="'+E+'" alt="image-20250624170459981"></p><p>发现8084这个新的实例确实属于<code>BJ</code>这个集群了。</p><h2 id="_3-eureka" tabindex="-1"><a class="header-anchor" href="#_3-eureka"><span>3 Eureka</span></a></h2><p>Eureka是Netflix公司开源的一个服务注册中心组件，早期版本的SpringCloud都是使用Eureka作为注册中心。由于Eureka和Nacos的starter中提供的功能都是基于SpringCloudCommon规范，因此两者使用起来差别不大。</p><p>课前资料中提供了一个Eureka的demo：</p><p><img src="'+N+'" alt="image-20250624170529520"></p><p>我们可以用idea打开查看一下：</p><p><img src="'+y+'" alt="image-20250624170546316"></p><p>结构说明：</p><ul><li><code>eureka-server</code>：Eureka的服务端，也就是注册中心。没错，Eureka服务端要自己创建项目</li><li><code>order-service</code>：订单服务，是一个服务调用者，查询订单的时候要查询用户</li><li><code>user-service</code>：用户服务，是一个服务提供者，对外暴露查询用户的接口</li></ul><p>启动以后，访问<code>localhost:10086</code>即可查看到Eureka的控制台，相对于Nacos来说简陋了很多：</p><p><img src="'+w+'" alt="image-20250624170558292"></p><p>微服务引入Eureka的方式也极其简单，分两步：</p><ul><li>引入<code>eureka-client</code>依赖</li><li>配置<code>eureka</code>地址</li></ul><p>接下来就是编写OpenFeign的客户端了，怎么样？是不是跟Nacos用起来基本一致。</p><h2 id="_4-eureka-和-nacos-对比" tabindex="-1"><a class="header-anchor" href="#_4-eureka-和-nacos-对比"><span>4 Eureka 和 Nacos 对比</span></a></h2><p>Eureka和Nacos都能起到注册中心的作用，用法基本类似。但还是有一些区别的，例如：</p><ul><li>Nacos支持配置管理，而Eureka则不支持。</li></ul><p>而且服务注册发现上也有区别，我们来做一个实验：</p><p>我们停止<code>user-service</code>服务，然后观察Eureka控制台，你会发现很长一段时间过去后，Eureka服务依然没有察觉<code>user-service</code>的异常状态。</p><p>这与Eureka的健康检测机制有关。在Eureka中，健康检测的原理如下：</p><ul><li>微服务启动时注册信息到Eureka，这点与Nacos一致。</li><li>微服务每隔30秒向Eureka发送心跳请求，报告自己的健康状态。Nacos中默认是5秒一次。</li><li>Eureka如果90秒未收到心跳，则认为服务疑似故障，可能被剔除。Nacos中则是15秒超时，30秒剔除。</li><li>Eureka如果发现超过85%比例的服务都心跳异常，会认为是自己的网络异常，暂停剔除服务的功能。</li><li>Eureka每隔60秒执行一次服务检测和清理任务；Nacos是每隔5秒执行一次。</li></ul><p>综上，你会发现Eureka是尽量不剔除服务，避免“误杀”，宁可放过一千，也不错杀一个。这就导致当服务真的出现故障时，迟迟不会被剔除，给服务的调用者带来困扰。</p><p>不仅如此，当Eureka发现服务宕机并从服务列表中剔除以后，并不会将服务列表的变更消息推送给所有微服务。而是等待微服务自己来拉取时发现服务列表的变化。而微服务每隔30秒才会去Eureka更新一次服务列表，进一步推迟了服务宕机时被发现的时间。</p><p>而Nacos中微服务除了自己定时去Nacos中拉取服务列表以外，Nacos还会在服务列表变更时主动推送最新的服务列表给所有的订阅者。</p><p>综上，Eureka和Nacos的相似点有：</p><ul><li>都支持服务注册发现功能</li><li>都有基于心跳的健康监测功能</li><li>都支持集群，集群间数据同步默认是AP模式，即最全高可用性</li></ul><p>Eureka和Nacos的区别有：</p><ul><li>Eureka的心跳是30秒一次，Nacos则是5秒一次</li><li>Eureka如果90秒未收到心跳，则认为服务疑似故障，可能被剔除。Nacos中则是15秒超时，30秒剔除。</li><li>Eureka每隔60秒执行一次服务检测和清理任务；Nacos是每隔5秒执行一次。</li><li>Eureka只能等微服务自己每隔30秒更新一次服务列表；Nacos即有定时更新，也有在服务变更时的广播推送</li><li>Eureka仅有注册中心功能，而Nacos同时支持注册中心、配置管理</li><li>Eureka和Nacos都支持集群，而且默认都是AP模式</li></ul>',90)]))}const C=s(x,[["render",f]]),D=JSON.parse('{"path":"/docs/Java/Heima/Microservices/Day11_MicroservicesInterview/2-MicroservicesInterview.html","title":"注册中心","lang":"en-US","frontmatter":{"title":"注册中心","date":"2025/03/06"},"headers":[{"level":2,"title":"1 环境隔离","slug":"_1-环境隔离","link":"#_1-环境隔离","children":[{"level":3,"title":"1.1 创建 namespace","slug":"_1-1-创建-namespace","link":"#_1-1-创建-namespace","children":[]},{"level":3,"title":"1.2 微服务配置 namespace","slug":"_1-2-微服务配置-namespace","link":"#_1-2-微服务配置-namespace","children":[]}]},{"level":2,"title":"2 分级模型","slug":"_2-分级模型","link":"#_2-分级模型","children":[]},{"level":2,"title":"3 Eureka","slug":"_3-eureka","link":"#_3-eureka","children":[]},{"level":2,"title":"4 Eureka 和 Nacos 对比","slug":"_4-eureka-和-nacos-对比","link":"#_4-eureka-和-nacos-对比","children":[]}],"filePathRelative":"docs/Java/Heima/Microservices/Day11_MicroservicesInterview/2-MicroservicesInterview.md","git":{"createdTime":1741251281000,"updatedTime":1750756522000,"contributors":[{"name":"lixuan","email":"2789968443@qq.com","commits":2}]}}');export{C as comp,D as data};
