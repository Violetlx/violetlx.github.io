import{_ as i,c as p,b as a,a as l,d as s,e as r,r as n,o}from"./app-B_5tQx1u.js";const d="/assets/image-20210725152037611-D6t2bgX2.png",m="/assets/image-20210725152052501-C8jwnLiw.png",g="/assets/image-20210725152222497-Xo9sBVb9.png",c="/assets/image-20210725152700914-Ccxgr8Eh.png",_="/assets/image-20210725153201086-CUglEHkt.png",f="/assets/image-20210725153359022-BF4rb0VB.png",v="/assets/image-20210725153524190-Bj-Zz8ZF.png",h="/assets/image-20210725153715910-B2yuwQ9g.png",k="/assets/image-20210725153937031-DeHrJdO0.png",u="/assets/image-20210725154155984-BzSfF7DZ.png",b="/assets/image-20210725154216392-CnfXTfnl.png",R="/assets/image-20210725154405899-Dvjp-k4Y.png",x={},B={href:"http://xn--Redis-2o3nn90k.md",target:"_blank",rel:"noopener noreferrer"};function D(w,e){const t=n("ExternalLinkIcon");return o(),p("div",null,[e[3]||(e[3]=a('<p><img src="https://bizhi1.com/wp-content/uploads/2024/08/sakura-anime-girl-desktop-wallpaper-4k-small.jpg" alt="樱花动漫女孩桌面壁纸"></p><div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>① 搭建主从结构</p><p>② 主从书同步原理</p><p>③ 主从同步优化</p><p>④ 小结</p></div><h2 id="_1-搭建主从结构" tabindex="-1"><a class="header-anchor" href="#_1-搭建主从结构"><span>① 搭建主从结构</span></a></h2><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p><p><img src="'+d+'" alt="image-20210725152037611"></p>',5)),l("p",null,[e[1]||(e[1]=s("具体搭建流程参考课前资料《")),l("a",B,[e[0]||(e[0]=s("Redis集群.md")),r(t)]),e[2]||(e[2]=s("》："))]),e[4]||(e[4]=a('<p><img src="'+m+'" alt="image-20210725152052501"></p><h2 id="_2-主从书同步原理" tabindex="-1"><a class="header-anchor" href="#_2-主从书同步原理"><span>② 主从书同步原理</span></a></h2><h3 id="_2-1-全量同步" tabindex="-1"><a class="header-anchor" href="#_2-1-全量同步"><span>2.1.全量同步</span></a></h3><p>主从第一次建立连接时，会执行<strong>全量同步</strong>，将master节点的所有数据都拷贝给slave节点，流程：</p><p><img src="'+g+'" alt="image-20210725152222497"></p><p>这里有一个问题，master如何得知salve是第一次来连接呢？？</p><p>有几个概念，可以作为判断依据：</p><ul><li><strong>Replication Id</strong>：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid</li><li><strong>offset</strong>：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</li></ul><p>因此slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底需要同步哪些数据。</p><p>因为slave原本也是一个master，有自己的replid和offset，当第一次变成slave，与master建立连接时，发送的replid和offset是自己的replid和offset。</p><p>master判断发现slave发送来的replid与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。</p><p>master会将自己的replid和offset都发送给这个slave，slave保存这些信息。以后slave的replid就与master一致了。</p><p>因此，<strong>master判断一个节点是否是第一次同步的依据，就是看replid是否一致</strong>。</p><p>如图：</p><p><img src="'+c+'" alt="image-20210725152700914"></p><p>完整流程描述：</p><ul><li>slave节点请求增量同步</li><li>master节点判断replid，发现不一致，拒绝增量同步</li><li>master将完整内存数据生成RDB，发送RDB到slave</li><li>slave清空本地数据，加载master的RDB</li><li>master将RDB期间的命令记录在repl_baklog，并持续将log中的命令发送给slave</li><li>slave执行接收到的命令，保持与master之间的同步</li></ul><h3 id="_2-2-增量同步" tabindex="-1"><a class="header-anchor" href="#_2-2-增量同步"><span>2.2.增量同步</span></a></h3><p>全量同步需要先做RDB，然后将RDB文件通过网络传输个slave，成本太高了。因此除了第一次做全量同步，其它大多数时候slave与master都是做<strong>增量同步</strong>。</p><p>什么是增量同步？就是只更新slave与master存在差异的部分数据。如图：</p><p><img src="'+_+'" alt="image-20210725153201086"></p><p>那么master怎么知道slave与自己的数据差异在哪里呢?</p><h3 id="_2-3-repl-backlog原理" tabindex="-1"><a class="header-anchor" href="#_2-3-repl-backlog原理"><span>2.3.repl_backlog原理</span></a></h3><p>master怎么知道slave与自己的数据差异在哪里呢?</p><p>这就要说到全量同步时的repl_baklog文件了。</p><p>这个文件是一个固定大小的数组，只不过数组是环形，也就是说<strong>角标到达数组末尾后，会再次从0开始读写</strong>，这样数组头部的数据就会被覆盖。</p><p>repl_baklog中会记录Redis处理过的命令日志及offset，包括master当前的offset，和slave已经拷贝到的offset：</p><p><img src="'+f+'" alt="image-20210725153359022"></p><p>slave与master的offset之间的差异，就是salve需要增量拷贝的数据了。</p><p>随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset：</p><p><img src="'+v+'" alt="image-20210725153524190"></p><p>直到数组被填满：</p><p><img src="'+h+'" alt="image-20210725153715910"></p><p>此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分。</p><p>但是，如果slave出现网络阻塞，导致master的offset远远超过了slave的offset：</p><p><img src="'+k+'" alt="image-20210725153937031"></p><p>如果master继续写入新数据，其offset就会覆盖旧的数据，直到将slave现在的offset也覆盖：</p><p><img src="'+u+'" alt="image-20210725154155984"></p><p>棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现自己的offset都没有了，无法完成增量同步了。只能做全量同步。</p><p><img src="'+b+'" alt="image-20210725154216392"></p><h2 id="_3-主从同步优化" tabindex="-1"><a class="header-anchor" href="#_3-主从同步优化"><span>③ 主从同步优化</span></a></h2><p>主从同步可以保证主从数据的一致性，非常重要。</p><p>可以从以下几个方面来优化Redis主从就集群：</p><ul><li>在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO。</li><li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO</li><li>适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</li><li>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力</li></ul><p>主从从架构图：</p><p><img src="'+R+'" alt="image-20210725154405899"></p><h2 id="_4-小结" tabindex="-1"><a class="header-anchor" href="#_4-小结"><span>④ 小结</span></a></h2><p>简述全量同步和增量同步区别？</p><ul><li>全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。</li><li>增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave</li></ul><p>什么时候执行全量同步？</p><ul><li>slave节点第一次连接master节点时</li><li>slave节点断开时间太久，repl_baklog中的offset已经被覆盖时</li></ul><p>什么时候执行增量同步？</p><ul><li>slave节点断开又恢复，并且在repl_baklog中能找到offset时</li></ul>',53))])}const C=i(x,[["render",D]]),I=JSON.parse('{"path":"/docs/Middleware/Redis/Redis_Heima/3_Redis_Advanced/1_Redis_Advanced_Distributed/3-Redis_Advanced_Distributed.html","title":"Redis主从","lang":"en-US","frontmatter":{"title":"Redis主从","date":"2025/06/19"},"headers":[{"level":2,"title":"① 搭建主从结构","slug":"_1-搭建主从结构","link":"#_1-搭建主从结构","children":[]},{"level":2,"title":"② 主从书同步原理","slug":"_2-主从书同步原理","link":"#_2-主从书同步原理","children":[{"level":3,"title":"2.1.全量同步","slug":"_2-1-全量同步","link":"#_2-1-全量同步","children":[]},{"level":3,"title":"2.2.增量同步","slug":"_2-2-增量同步","link":"#_2-2-增量同步","children":[]},{"level":3,"title":"2.3.repl_backlog原理","slug":"_2-3-repl-backlog原理","link":"#_2-3-repl-backlog原理","children":[]}]},{"level":2,"title":"③ 主从同步优化","slug":"_3-主从同步优化","link":"#_3-主从同步优化","children":[]},{"level":2,"title":"④ 小结","slug":"_4-小结","link":"#_4-小结","children":[]}],"filePathRelative":"docs/Middleware/Redis/Redis_Heima/3_Redis_Advanced/1_Redis_Advanced_Distributed/3-Redis_Advanced_Distributed.md","git":{"createdTime":1750319780000,"updatedTime":1750319780000,"contributors":[{"name":"lixuan","email":"2789968443@qq.com","commits":1}]}}');export{C as comp,I as data};
