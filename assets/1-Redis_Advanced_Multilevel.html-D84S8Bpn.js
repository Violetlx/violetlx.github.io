import{_ as e,c as t,b as l,o as a}from"./app-0ki2vGVh.js";const s="/assets/image-20210821075259137-B3smCpZD.png",n="/assets/image-20210821075558137-CFO54te0.png",p="/assets/image-20210821080511581-I1m6KrKP.png",c="/assets/image-20210821080954947-B0w1r0jT.png",o={};function d(r,i){return a(),t("div",null,i[0]||(i[0]=[l('<p><img src="https://bizhi1.com/wp-content/uploads/2024/08/rem-winking-rezero-anime-pc-wallpaper-4k-small.jpg" alt="REM WINKING RE 动漫桌面壁纸"></p><h2 id="统计" tabindex="-1"><a class="header-anchor" href="#统计"><span>统计</span></a></h2><div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><ul><li>什么是多级缓存</li><li>JVM进程缓存</li><li>Lua语法入门</li><li>实现多级缓存</li><li>缓存同步</li></ul></div><h2 id="具体" tabindex="-1"><a class="header-anchor" href="#具体"><span>具体</span></a></h2><p>传统的缓存策略一般是请求到达Tomcat后，先查询Redis，如果未命中则查询数据库，如图：</p><p><img src="'+s+'" alt="image-20210821075259137"></p><p>存在下面的问题：</p><p>•请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈</p><p>•Redis缓存失效时，会对数据库产生冲击</p><p>多级缓存就是充分利用请求处理的每个环节，分别添加缓存，减轻Tomcat压力，提升服务性能：</p><ul><li>浏览器访问静态资源时，优先读取浏览器本地缓存</li><li>访问非静态资源（ajax查询数据）时，访问服务端</li><li>请求到达Nginx后，优先读取Nginx本地缓存</li><li>如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）</li><li>如果Redis查询未命中，则查询Tomcat</li><li>请求进入Tomcat后，优先查询JVM进程缓存</li><li>如果JVM进程缓存未命中，则查询数据库</li></ul><p><img src="'+n+'" alt="image-20210821075558137"></p><p>在多级缓存架构中，Nginx内部需要编写本地缓存查询、Redis查询、Tomcat查询的业务逻辑，因此这样的nginx服务不再是一个<strong>反向代理服务器</strong>，而是一个编写<strong>业务的Web服务器了</strong>。</p><p>因此这样的业务Nginx服务也需要搭建集群来提高并发，再有专门的nginx服务来做反向代理，如图：</p><p><img src="'+p+'" alt="image-20210821080511581"></p><p>另外，我们的Tomcat服务将来也会部署为集群模式：</p><p><img src="'+c+'" alt="image-20210821080954947"></p><p>可见，多级缓存的关键有两个：</p><ul><li><p>一个是在nginx中编写业务，实现nginx本地缓存、Redis、Tomcat的查询</p></li><li><p>另一个就是在Tomcat中实现JVM进程缓存</p></li></ul><p>其中Nginx编程则会用到OpenResty框架结合Lua这样的语言。</p>',20)]))}const g=e(o,[["render",d]]),_=JSON.parse('{"path":"/docs/Middleware/Redis/Redis_Heima/3_Redis_Advanced/2_Redis_Advanced_Multilevel/1-Redis_Advanced_Multilevel.html","title":"Redis多级缓存介绍","lang":"en-US","frontmatter":{"title":"Redis多级缓存介绍","date":"2025/06/19"},"headers":[{"level":2,"title":"统计","slug":"统计","link":"#统计","children":[]},{"level":2,"title":"具体","slug":"具体","link":"#具体","children":[]}],"filePathRelative":"docs/Middleware/Redis/Redis_Heima/3_Redis_Advanced/2_Redis_Advanced_Multilevel/1-Redis_Advanced_Multilevel.md","git":{"createdTime":1750319780000,"updatedTime":1750319780000,"contributors":[{"name":"lixuan","email":"2789968443@qq.com","commits":1}]}}');export{g as comp,_ as data};
