import{_ as e,c as a,b as n,o as l}from"./app-CezBFXHK.js";const t="/assets/image-20250624162258693-CuM62w1_.png",p="/assets/image-20250624162345884-CwHJll5C.png",i="/assets/image-20250624162357910-CQ-W-E1r.png",o="/assets/image-20250624162412520-DEsgieNj.png",c="/assets/image-20250624162421774-BjYu03_y.png",r="/assets/image-20250624162432115-C8l7cwp1.png",d="/assets/image-20250624162623696-LGnyM41G.png",m="/assets/image-20250624162635312-C6wF-XU6.png",u="/assets/image-20250624162648456-BEaTsSbh.png",v="/assets/image-20250624162700118-BWtx9vG8.png",g="/assets/image-20250624162721026-DphkEaq4.png",k="/assets/image-20250624162754073-CTpnBq8g.png",b="/assets/image-20250624162810647-DEJXTtUE.png",h="/assets/image-20250624162822991-BhB2F20s.png",_="/assets/image-20250624162837363-BIzMRwa3.png",f="/assets/image-20250624162847494-BAGpStrO.png",y="/assets/image-20250624162904890-B0dOTNNG.png",x="/assets/image-20250624162956081-Ch_LCsT9.png",R={};function q(w,s){return l(),a("div",null,s[0]||(s[0]=[n('<p><img src="https://bizhi1.com/wp-content/uploads/2024/11/porsche-911-sportscar-desktop-wallpaper-4k.jpg" alt="保时捷 911 跑车桌面壁纸"></p><div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>1 主从集群结构</p><p>2 搭建主从集群</p><p>3 主从同步原理</p><p>4 主从同步优化</p></div><p>经过前几天的学习，大家已经掌握了微服务相关技术的实际应用，能够应对企业开发的要求了。不过大家都知道在IT领域往往都是面试造火箭，实际工作拧螺丝。</p><p>为了更好的应对面试，让大家能拿到更高的offer，我们接下来就讲讲“造火箭”的事情。</p><p>接下来的内容主要包括以下几方面：</p><p>Redis高级：</p><ul><li>Redis主从</li><li>Redis哨兵</li><li>Redis分片集群</li><li>Redis数据结构</li><li>Redis内存回收</li><li>Redis缓存一致性</li></ul><p>微服务高级：</p><ul><li>Eureka和Nacos对比</li><li>Ribbon和SpringCloudLoadBalancer</li><li>Hystix和Sentinel</li><li>限流算法</li></ul><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p><h2 id="_1-主从集群结构" tabindex="-1"><a class="header-anchor" href="#_1-主从集群结构"><span>1 主从集群结构</span></a></h2><p>下图就是一个简单的Redis主从集群结构：</p><p><img src="'+t+'" alt="image-20250624162258693"></p><p>如图所示，集群中有一个master节点、两个slave节点（现在叫replica）。当我们通过Redis的Java客户端访问主从集群时，应该做好路由：</p><ul><li>如果是写操作，应该访问master节点，master会自动将数据同步给两个slave节点</li><li>如果是读操作，建议访问各个slave节点，从而分担并发压力</li></ul><h2 id="_2-搭建主从集群" tabindex="-1"><a class="header-anchor" href="#_2-搭建主从集群"><span>2 搭建主从集群</span></a></h2><p>我们会在同一个虚拟机中利用3个Docker容器来搭建主从集群，容器信息如下：</p><table><thead><tr><th style="text-align:left;"><strong>容器名</strong></th><th style="text-align:left;"><strong>角色</strong></th><th style="text-align:left;"><strong>IP</strong></th><th style="text-align:left;"><strong>映射****端口</strong></th></tr></thead><tbody><tr><td style="text-align:left;">r1</td><td style="text-align:left;">master</td><td style="text-align:left;">192.168.150.101</td><td style="text-align:left;">7001</td></tr><tr><td style="text-align:left;">r2</td><td style="text-align:left;">slave</td><td style="text-align:left;">192.168.150.101</td><td style="text-align:left;">7002</td></tr><tr><td style="text-align:left;">r3</td><td style="text-align:left;">slave</td><td style="text-align:left;">192.168.150.101</td><td style="text-align:left;">7003</td></tr></tbody></table><h3 id="_2-1-启动多个-redis-实例" tabindex="-1"><a class="header-anchor" href="#_2-1-启动多个-redis-实例"><span>2.1 启动多个 Redis 实例</span></a></h3><p>我们利用课前资料提供的docker-compose文件来构建主从集群：</p><p><img src="'+p+`" alt="image-20250624162345884"></p><p>文件内容如下：</p><div class="language-yaml line-numbers-mode" data-highlighter="prismjs" data-ext="yml" data-title="yml"><pre><code><span class="line"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">&quot;3.2&quot;</span></span>
<span class="line"></span>
<span class="line"><span class="token key atrule">services</span><span class="token punctuation">:</span></span>
<span class="line">  <span class="token key atrule">r1</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis</span>
<span class="line">    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> r1</span>
<span class="line">    <span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">&quot;host&quot;</span></span>
<span class="line">    <span class="token key atrule">entrypoint</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;redis-server&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--port&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;7001&quot;</span><span class="token punctuation">]</span></span>
<span class="line">  <span class="token key atrule">r2</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis</span>
<span class="line">    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> r2</span>
<span class="line">    <span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">&quot;host&quot;</span></span>
<span class="line">    <span class="token key atrule">entrypoint</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;redis-server&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--port&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;7002&quot;</span><span class="token punctuation">]</span></span>
<span class="line">  <span class="token key atrule">r3</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis</span>
<span class="line">    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> r3</span>
<span class="line">    <span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">&quot;host&quot;</span></span>
<span class="line">    <span class="token key atrule">entrypoint</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;redis-server&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--port&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;7003&quot;</span><span class="token punctuation">]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将其上传至虚拟机的<code>/root/redis</code>目录下：</p><p><img src="`+i+`" alt="image-20250624162357910"></p><p>执行命令，运行集群：</p><div class="language-Bash line-numbers-mode" data-highlighter="prismjs" data-ext="Bash" data-title="Bash"><pre><code><span class="line">docker compose up -d</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>结果：</p><p><img src="`+o+'" alt="image-20250624162412520"></p><p>查看docker容器，发现都正常启动了：</p><p><img src="'+c+'" alt="image-20250624162421774"></p><p>由于采用的是host模式，我们看不到端口映射。不过能直接在宿主机通过ps命令查看到Redis进程：</p><p><img src="'+r+`" alt="image-20250624162432115"></p><h3 id="_2-2-建立集群" tabindex="-1"><a class="header-anchor" href="#_2-2-建立集群"><span>2.2 建立集群</span></a></h3><p>虽然我们启动了3个Redis实例，但是它们并没有形成主从关系。我们需要通过命令来配置主从关系：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token comment"># Redis5.0以前</span></span>
<span class="line">slaveof <span class="token operator">&lt;</span>masterip<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>masterport<span class="token operator">&gt;</span></span>
<span class="line"><span class="token comment"># Redis5.0以后</span></span>
<span class="line">replicaof <span class="token operator">&lt;</span>masterip<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>masterport<span class="token operator">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有临时和永久两种模式：</p><ul><li>永久生效：在redis.conf文件中利用<code>slaveof</code>命令指定<code>master</code>节点</li><li>临时生效：直接利用redis-cli控制台输入<code>slaveof</code>命令，指定<code>master</code>节点</li></ul><p>我们测试临时模式，首先连接<code>r2</code>，让其以<code>r1</code>为master</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token comment"># 连接r2</span></span>
<span class="line"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> r2 redis-cli <span class="token parameter variable">-p</span> <span class="token number">7002</span></span>
<span class="line"><span class="token comment"># 认r1主，也就是7001</span></span>
<span class="line">slaveof <span class="token number">192.168</span>.150.101 <span class="token number">7001</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后连接<code>r3</code>，让其以<code>r1</code>为master</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token comment"># 连接r3</span></span>
<span class="line"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> r3 redis-cli <span class="token parameter variable">-p</span> <span class="token number">7003</span></span>
<span class="line"><span class="token comment"># 认r1主，也就是7001</span></span>
<span class="line">slaveof <span class="token number">192.168</span>.150.101 <span class="token number">7001</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后连接<code>r1</code>，查看集群状态：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token comment"># 连接r1</span></span>
<span class="line"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> r1 redis-cli <span class="token parameter variable">-p</span> <span class="token number">7001</span></span>
<span class="line"><span class="token comment"># 查看集群状态</span></span>
<span class="line">info replication</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果如下：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token number">127.0</span>.0.1:700<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span> info replication</span>
<span class="line"><span class="token comment"># Replication</span></span>
<span class="line">role:master</span>
<span class="line">connected_slaves:2</span>
<span class="line">slave0:ip<span class="token operator">=</span><span class="token number">192.168</span>.150.101,port<span class="token operator">=</span><span class="token number">7002</span>,state<span class="token operator">=</span>online,offset<span class="token operator">=</span><span class="token number">140</span>,lag<span class="token operator">=</span><span class="token number">1</span></span>
<span class="line">slave1:ip<span class="token operator">=</span><span class="token number">192.168</span>.150.101,port<span class="token operator">=</span><span class="token number">7003</span>,state<span class="token operator">=</span>online,offset<span class="token operator">=</span><span class="token number">140</span>,lag<span class="token operator">=</span><span class="token number">1</span></span>
<span class="line">master_failover_state:no-failover</span>
<span class="line">master_replid:16d90568498908b322178ca12078114e6c518b86</span>
<span class="line">master_replid2:0000000000000000000000000000000000000000</span>
<span class="line">master_repl_offset:140</span>
<span class="line">second_repl_offset:-1</span>
<span class="line">repl_backlog_active:1</span>
<span class="line">repl_backlog_size:1048576</span>
<span class="line">repl_backlog_first_byte_offset:1</span>
<span class="line">repl_backlog_histlen:140</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，当前节点<code>r1:7001</code>的角色是<code>master</code>，有两个slave与其连接：</p><ul><li><code>slave0</code>：<code>port</code>是<code>7002</code>，也就是<code>r2</code>节点</li><li><code>slave1</code>：<code>port</code>是<code>7003</code>，也就是<code>r3</code>节点</li></ul><h3 id="_2-3-测试" tabindex="-1"><a class="header-anchor" href="#_2-3-测试"><span>2.3 测试</span></a></h3><p>依次在<code>r1</code>、<code>r2</code>、<code>r3</code>节点上执行下面命令：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token builtin class-name">set</span> num <span class="token number">123</span></span>
<span class="line"></span>
<span class="line">get num</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你会发现，只有在<code>r1</code>这个节点上可以执行<code>set</code>命令（<strong>写操作</strong>），其它两个节点只能执行<code>get</code>命令（<strong>读操作</strong>）。也就是说读写操作已经分离了。</p><h2 id="_3-主从同步原理" tabindex="-1"><a class="header-anchor" href="#_3-主从同步原理"><span>3 主从同步原理</span></a></h2><p>在刚才的主从测试中，我们发现<code>r1</code>上写入Redis的数据，在<code>r2</code>和<code>r3</code>上也能看到，这说明主从之间确实完成了数据同步。</p><p>那么这个同步是如何完成的呢？</p><h3 id="_3-1-全量同步" tabindex="-1"><a class="header-anchor" href="#_3-1-全量同步"><span>3.1 全量同步</span></a></h3><p>主从第一次建立连接时，会执行<strong>全量同步</strong>，将master节点的所有数据都拷贝给slave节点，流程：</p><p><img src="`+d+'" alt="image-20250624162623696"></p><p>这里有一个问题，<code>master</code>如何得知<code>salve</code>是否是第一次来同步呢？？</p><p>有几个概念，可以作为判断依据：</p><ul><li><strong><code>Replication Id</code></strong>：简称<code>replid</code>，是数据集的标记，replid一致则是同一数据集。每个<code>master</code>都有唯一的<code>replid</code>，<code>slave</code>则会继承<code>master</code>节点的<code>replid</code></li><li><strong><code>offset</code></strong>：偏移量，随着记录在<code>repl_baklog</code>中的数据增多而逐渐增大。<code>slave</code>完成同步时也会记录当前同步的<code>offset</code>。如果<code>slave</code>的<code>offset</code>小于<code>master</code>的<code>offset</code>，说明<code>slave</code>数据落后于<code>master</code>，需要更新。</li></ul><p>因此<code>slave</code>做数据同步，必须向<code>master</code>声明自己的<code>replication id </code>和<code>offset</code>，<code>master</code>才可以判断到底需要同步哪些数据。</p><p>由于我们在执行<code>slaveof</code>命令之前，所有redis节点都是<code>master</code>，有自己的<code>replid</code>和<code>offset</code>。</p><p>当我们第一次执行<code>slaveof</code>命令，与<code>master</code>建立主从关系时，发送的<code>replid</code>和<code>offset</code>是自己的，与<code>master</code>肯定不一致。</p><p><code>master</code>判断发现<code>slave</code>发送来的<code>replid</code>与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。</p><p><code>master</code>会将自己的<code>replid</code>和<code>offset</code>都发送给这个<code>slave</code>，<code>slave</code>保存这些信息到本地。自此以后<code>slave</code>的<code>replid</code>就与<code>master</code>一致了。</p><p>因此，<strong>master****判断一个节点是否是第一次同步的依据，就是看replid是否一致</strong>。流程如图：</p><p><img src="'+m+'" alt="image-20250624162635312"></p><p>完整流程描述：</p><ul><li><code>slave</code>节点请求增量同步</li><li><code>master</code>节点判断<code>replid</code>，发现不一致，拒绝增量同步</li><li><code>master</code>将完整内存数据生成<code>RDB</code>，发送<code>RDB</code>到<code>slave</code></li><li><code>slave</code>清空本地数据，加载<code>master</code>的<code>RDB</code></li><li><code>master</code>将<code>RDB</code>期间的命令记录在<code>repl_baklog</code>，并持续将log中的命令发送给<code>slave</code></li><li><code>slave</code>执行接收到的命令，保持与<code>master</code>之间的同步</li></ul><p>来看下<code>r1</code>节点的运行日志：</p><p><img src="'+u+'" alt="image-20250624162648456"></p><p>再看下<code>r2</code>节点执行<code>replicaof</code>命令时的日志：</p><p><img src="'+v+'" alt="image-20250624162700118"></p><p>与我们描述的完全一致。</p><h3 id="_3-2-增量同步" tabindex="-1"><a class="header-anchor" href="#_3-2-增量同步"><span>3.2 增量同步</span></a></h3><p>全量同步需要先做RDB，然后将RDB文件通过网络传输个slave，成本太高了。因此除了第一次做全量同步，其它大多数时候slave与master都是做<strong>增量同步</strong>。</p><p>什么是增量同步？就是只更新slave与master存在差异的部分数据。如图：</p><p><img src="'+g+'" alt="image-20250624162721026"></p><p>那么master怎么知道slave与自己的数据差异在哪里呢?</p><h3 id="_3-3-repl-baklog-原理" tabindex="-1"><a class="header-anchor" href="#_3-3-repl-baklog-原理"><span>3.3 repl_baklog 原理</span></a></h3><p>master怎么知道slave与自己的数据差异在哪里呢?</p><p>这就要说到全量同步时的<code>repl_baklog</code>文件了。这个文件是一个固定大小的数组，只不过数组是环形，也就是说<strong>角标到达数组末尾后，会再次从0开始读写</strong>，这样数组头部的数据就会被覆盖。</p><p><code>repl_baklog</code>中会记录Redis处理过的命令及<code>offset</code>，包括master当前的<code>offset</code>，和slave已经拷贝到的<code>offset</code>：</p><p><img src="'+k+'" alt="image-20250624162754073"></p><p>slave与master的offset之间的差异，就是salve需要增量拷贝的数据了。</p><p>随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset：</p><p><img src="'+b+'" alt="image-20250624162810647"></p><p>直到数组被填满：</p><p><img src="'+h+'" alt="image-20250624162822991"></p><p>此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分：</p><p><img src="'+_+'" alt="image-20250624162837363"></p><p>但是，如果slave出现网络阻塞，导致master的<code>offset</code>远远超过了slave的<code>offset</code>：</p><p><img src="'+f+'" alt="image-20250624162847494"></p><p>如果master继续写入新数据，master的<code>offset</code>就会覆盖<code>repl_baklog</code>中旧的数据，直到将slave现在的<code>offset</code>也覆盖：</p><p><img src="'+y+'" alt="image-20250624162904890"></p><p>棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现自己的<code>offset</code>都没有了，无法完成增量同步了。只能做<strong>全量同步</strong>。</p><p><code>repl_baklog</code>大小有上限，写满后会覆盖最早的数据。如果slave断开时间过久，导致尚未备份的数据被覆盖，则无法基于<code>repl_baklog</code>做增量同步，只能再次全量同步。</p><h2 id="_4-主从同步优化" tabindex="-1"><a class="header-anchor" href="#_4-主从同步优化"><span>4 主从同步优化</span></a></h2><p>主从同步可以保证主从数据的一致性，非常重要。</p><p>可以从以下几个方面来优化Redis主从就集群：</p><ul><li>在master中配置<code>repl-diskless-sync yes</code>启用无磁盘复制，避免全量同步时的磁盘IO。</li><li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO</li><li>适当提高<code>repl_baklog</code>的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</li><li>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用<code>主-从-从</code>链式结构，减少master压力</li></ul><p><code>主-从-从</code>架构图：</p><p><img src="'+x+'" alt="image-20250624162956081"></p><p>简述全量同步和增量同步区别？</p><ul><li>全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。</li><li>增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave</li></ul><p>什么时候执行全量同步？</p><ul><li>slave节点第一次连接master节点时</li><li>slave节点断开时间太久，repl_baklog中的offset已经被覆盖时</li></ul><p>什么时候执行增量同步？</p><ul><li>slave节点断开又恢复，并且在<code>repl_baklog</code>中能找到offset时</li></ul>',110)]))}const D=e(R,[["render",q]]),j=JSON.parse('{"path":"/docs/Java/Heima/Microservices/Day10_RedisInterview/1-RedisInterview.html","title":"Redis主从","lang":"en-US","frontmatter":{"title":"Redis主从","date":"2025/03/06"},"headers":[{"level":2,"title":"1 主从集群结构","slug":"_1-主从集群结构","link":"#_1-主从集群结构","children":[]},{"level":2,"title":"2 搭建主从集群","slug":"_2-搭建主从集群","link":"#_2-搭建主从集群","children":[{"level":3,"title":"2.1 启动多个 Redis 实例","slug":"_2-1-启动多个-redis-实例","link":"#_2-1-启动多个-redis-实例","children":[]},{"level":3,"title":"2.2 建立集群","slug":"_2-2-建立集群","link":"#_2-2-建立集群","children":[]},{"level":3,"title":"2.3 测试","slug":"_2-3-测试","link":"#_2-3-测试","children":[]}]},{"level":2,"title":"3 主从同步原理","slug":"_3-主从同步原理","link":"#_3-主从同步原理","children":[{"level":3,"title":"3.1 全量同步","slug":"_3-1-全量同步","link":"#_3-1-全量同步","children":[]},{"level":3,"title":"3.2 增量同步","slug":"_3-2-增量同步","link":"#_3-2-增量同步","children":[]},{"level":3,"title":"3.3 repl_baklog 原理","slug":"_3-3-repl-baklog-原理","link":"#_3-3-repl-baklog-原理","children":[]}]},{"level":2,"title":"4 主从同步优化","slug":"_4-主从同步优化","link":"#_4-主从同步优化","children":[]}],"filePathRelative":"docs/Java/Heima/Microservices/Day10_RedisInterview/1-RedisInterview.md","git":{"createdTime":1741251281000,"updatedTime":1750756522000,"contributors":[{"name":"lixuan","email":"2789968443@qq.com","commits":2}]}}');export{D as comp,j as data};
