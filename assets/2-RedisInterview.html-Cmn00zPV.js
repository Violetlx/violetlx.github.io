import{_ as t,c as l,b as n,a,d as p,e as i,r as o,o as c}from"./app-DlQzn5rm.js";const d="/assets/image-20250624163034717-B55JNCcl.png",r="/assets/image-20250624163103361-D3HVf7Dy.png",u="/assets/image-20250624163137548-CWDYO4w1.png",m="/assets/image-20250624163158610-D-P_HX4P.png",k="/assets/image-20250624163211031-DJENg3PH.png",v="/assets/image-20250624163224924-DD5Aba3_.png",g="/assets/image-20250624163312259-BpuLLeu0.png",b="/assets/image-20250624163326609-DaUBgQqV.png",h="/assets/image-20250624163402019-x2QxRwni.png",f="/assets/image-20250624163437281-CfrZtJaM.png",_={},q={href:"https://redis.io/docs/management/sentinel/#replica-selection-and-priority",target:"_blank",rel:"noopener noreferrer"};function y(x,s){const e=o("ExternalLinkIcon");return c(),l("div",null,[s[1]||(s[1]=n('<p><img src="https://bizhi1.com/wp-content/uploads/2024/11/ford-gt-blue-racing-sportscar-desktop-wallpaper.jpg" alt="福特GT蓝色赛车跑车桌面壁纸"></p><div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>1 哨兵工作原理</p><p>2 搭建哨兵集群</p><p>3 演示 failover</p><p>4 总结</p><p>5 RedisTemplate 连接哨兵集群 (自学)</p></div><p>主从结构中master节点的作用非常重要，一旦故障就会导致集群不可用。那么有什么办法能保证主从集群的高可用性呢？</p><h2 id="_1-哨兵工作原理" tabindex="-1"><a class="header-anchor" href="#_1-哨兵工作原理"><span>1 哨兵工作原理</span></a></h2><p>Redis提供了<code>哨兵</code>（<code>Sentinel</code>）机制来监控主从集群监控状态，确保集群的高可用性。</p><h3 id="_1-1-哨兵作用" tabindex="-1"><a class="header-anchor" href="#_1-1-哨兵作用"><span>1.1 哨兵作用</span></a></h3><p>哨兵集群作用原理图：</p><p><img src="'+d+'" alt="image-20250624163034717"></p><p>哨兵的作用如下：</p><ul><li><strong>状态监控</strong>：<code>Sentinel</code> 会不断检查您的<code>master</code>和<code>slave</code>是否按预期工作</li><li><strong>故障恢复（failover）</strong>：如果<code>master</code>故障，<code>Sentinel</code>会将一个<code>slave</code>提升为<code>master</code>。当故障实例恢复后会成为<code>slave</code></li><li><strong>状态通知</strong>：<code>Sentinel</code>充当<code>Redis</code>客户端的服务发现来源，当集群发生<code>failover</code>时，会将最新集群信息推送给<code>Redis</code>的客户端</li></ul><p>那么问题来了，<code>Sentinel</code>怎么知道一个Redis节点是否宕机呢？</p><h3 id="_1-2-状态监控" tabindex="-1"><a class="header-anchor" href="#_1-2-状态监控"><span>1.2 状态监控</span></a></h3><p><code>Sentinel</code>基于心跳机制监测服务状态，每隔1秒向集群的每个节点发送ping命令，并通过实例的响应结果来做出判断：</p><ul><li><strong>主观下线（sdown）</strong>：如果某sentinel节点发现某Redis节点未在规定时间响应，则认为该节点主观下线。</li><li><strong>客观下线(odown)</strong>：若超过指定数量（通过<code>quorum</code>设置）的sentinel都认为该节点主观下线，则该节点客观下线。quorum值最好超过Sentinel节点数量的一半，Sentinel节点数量至少3台。</li></ul><p>如图：</p><p><img src="'+r+'" alt="image-20250624163103361"></p><p>一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：</p><ul><li>首先会判断slave节点与master节点断开时间长短，如果超过<code>down-after-milliseconds * 10</code>则会排除该slave节点</li><li>然后判断slave节点的<code>slave-priority</code>值，越小优先级越高，如果是0则永不参与选举（默认都是1）。</li><li>如果<code>slave-prority</code>一样，则判断slave节点的<code>offset</code>值，越大说明数据越新，优先级越高</li><li>最后是判断slave节点的<code>run_id</code>大小，越小优先级越高（<code>通过info server可以查看run_id</code>）。</li></ul><p>对应的官方文档如下：</p>',19)),a("p",null,[a("a",q,[s[0]||(s[0]=p("https://redis.io/docs/management/sentinel/#replica-selection-and-priority")),i(e)])]),s[2]||(s[2]=n('<p>问题来了，当选出一个新的master后，该如何实现身份切换呢？</p><p>大概分为两步：</p><ul><li>在多个<code>sentinel</code>中选举一个<code>leader</code></li><li>由<code>leader</code>执行<code>failover</code></li></ul><h3 id="_1-3-选举-leader" tabindex="-1"><a class="header-anchor" href="#_1-3-选举-leader"><span>1.3 选举 leader</span></a></h3><p>首先，Sentinel集群要选出一个执行<code>failover</code>的Sentinel节点，可以成为<code>leader</code>。要成为<code>leader</code>要满足两个条件：</p><ul><li>最先获得超过半数的投票</li><li>获得的投票数不小于<code>quorum</code>值</li></ul><p>而sentinel投票的原则有两条：</p><ul><li>优先投票给目前得票最多的</li><li>如果目前没有任何节点的票，就投给自己</li></ul><p>比如有3个sentinel节点，<code>s1</code>、<code>s2</code>、<code>s3</code>，假如<code>s2</code>先投票：</p><ul><li>此时发现没有任何人在投票，那就投给自己。<code>s2</code>得1票</li><li>接着<code>s1</code>和<code>s3</code>开始投票，发现目前<code>s2</code>票最多，于是也投给<code>s2</code>，<code>s2</code>得3票</li><li><code>s2</code>称为<code>leader</code>，开始故障转移</li></ul><p>不难看出，<strong>谁先<strong><strong>投票</strong></strong>，谁就会称为****leader</strong>，那什么时候会触发投票呢？</p><p>答案是<strong>第一个确认<strong><strong>master</strong></strong>客观下线<strong><strong>的人</strong></strong>会立刻发起<strong><strong>投票</strong></strong>，一定会成为****leader</strong>。</p><p>OK，<code>sentinel</code>找到<code>leader</code>以后，该如何完成<code>failover</code>呢？</p><h3 id="_1-4-failover" tabindex="-1"><a class="header-anchor" href="#_1-4-failover"><span>1.4 failover</span></a></h3><p>我们举个例子，有一个集群，初始状态下7001为<code>master</code>，7002和7003为<code>slave</code>：</p><p><img src="'+u+'" alt="image-20250624163137548"></p><p>假如master发生故障，slave1当选。则故障转移的流程如下：</p><p>1）<code>sentinel</code>给备选的<code>slave1</code>节点发送<code>slaveof no one</code>命令，让该节点成为<code>master</code></p><p><img src="'+m+'" alt="image-20250624163158610"></p><p>2）<code>sentinel</code>给所有其它<code>slave</code>发送<code>slaveof 192.168.150.101 7002</code> 命令，让这些节点成为新<code>master</code>，也就是<code>7002</code>的<code>slave</code>节点，开始从新的<code>master</code>上同步数据。</p><p><img src="'+k+'" alt="image-20250624163211031"></p><p>3）最后，当故障节点恢复后会接收到哨兵信号，执行<code>slaveof 192.168.150.101 7002</code>命令，成为<code>slave</code>：</p><p><img src="'+v+`" alt="image-20250624163224924"></p><h2 id="_2-搭建哨兵集群" tabindex="-1"><a class="header-anchor" href="#_2-搭建哨兵集群"><span>2 搭建哨兵集群</span></a></h2><p>首先，我们停掉之前的redis集群：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token comment"># 老版本DockerCompose</span></span>
<span class="line"><span class="token function">docker-compose</span> down</span>
<span class="line"></span>
<span class="line"><span class="token comment"># 新版本Docker</span></span>
<span class="line"><span class="token function">docker</span> compose down</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，我们找到课前资料提供的sentinel.conf文件：</p><p><img src="`+g+`" alt="image-20250624163312259"></p><p>其内容如下：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">sentinel announce-ip <span class="token string">&quot;192.168.150.101&quot;</span></span>
<span class="line">sentinel monitor hmaster <span class="token number">192.168</span>.150.101 <span class="token number">7001</span> <span class="token number">2</span></span>
<span class="line">sentinel down-after-milliseconds hmaster <span class="token number">5000</span></span>
<span class="line">sentinel failover-timeout hmaster <span class="token number">60000</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：</p><ul><li><code>sentinel announce-ip &quot;192.168.150.101&quot;</code>：声明当前sentinel的ip</li><li><code>sentinel monitor hmaster 192.168.150.101 7001 2</code>：指定集群的主节点信息 <ul><li><code>hmaster</code>：主节点名称，自定义，任意写</li><li><code>192.168.150.101 7001</code>：主节点的ip和端口</li><li><code>2</code>：认定<code>master</code>下线时的<code>quorum</code>值</li></ul></li><li><code>sentinel down-after-milliseconds hmaster 5000</code>：声明master节点超时多久后被标记下线</li><li><code>sentinel failover-timeout hmaster 60000</code>：在第一次故障转移失败后多久再次重试</li></ul><p>我们在虚拟机的<code>/root/redis</code>目录下新建3个文件夹：<code>s1</code>、<code>s2</code>、<code>s3</code>:</p><p><img src="`+b+`" alt="image-20250624163326609"></p><p>将课前资料提供的<code>sentinel.conf</code>文件分别拷贝一份到3个文件夹中。</p><p>接着修改<code>docker-compose.yaml</code>文件，内容如下：</p><div class="language-yaml line-numbers-mode" data-highlighter="prismjs" data-ext="yml" data-title="yml"><pre><code><span class="line"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">&quot;3.2&quot;</span></span>
<span class="line"></span>
<span class="line"><span class="token key atrule">services</span><span class="token punctuation">:</span></span>
<span class="line">  <span class="token key atrule">r1</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis</span>
<span class="line">    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> r1</span>
<span class="line">    <span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">&quot;host&quot;</span></span>
<span class="line">    <span class="token key atrule">entrypoint</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;redis-server&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--port&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;7001&quot;</span><span class="token punctuation">]</span></span>
<span class="line">  <span class="token key atrule">r2</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis</span>
<span class="line">    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> r2</span>
<span class="line">    <span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">&quot;host&quot;</span></span>
<span class="line">    <span class="token key atrule">entrypoint</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;redis-server&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--port&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;7002&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--slaveof&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;192.168.150.101&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;7001&quot;</span><span class="token punctuation">]</span></span>
<span class="line">  <span class="token key atrule">r3</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis</span>
<span class="line">    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> r3</span>
<span class="line">    <span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">&quot;host&quot;</span></span>
<span class="line">    <span class="token key atrule">entrypoint</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;redis-server&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--port&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;7003&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--slaveof&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;192.168.150.101&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;7001&quot;</span><span class="token punctuation">]</span></span>
<span class="line">  <span class="token key atrule">s1</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis</span>
<span class="line">    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> s1</span>
<span class="line">    <span class="token key atrule">volumes</span><span class="token punctuation">:</span></span>
<span class="line">      <span class="token punctuation">-</span> /root/redis/s1<span class="token punctuation">:</span>/etc/redis</span>
<span class="line">    <span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">&quot;host&quot;</span></span>
<span class="line">    <span class="token key atrule">entrypoint</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;redis-sentinel&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;/etc/redis/sentinel.conf&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--port&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;27001&quot;</span><span class="token punctuation">]</span></span>
<span class="line">  <span class="token key atrule">s2</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis</span>
<span class="line">    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> s2</span>
<span class="line">    <span class="token key atrule">volumes</span><span class="token punctuation">:</span></span>
<span class="line">      <span class="token punctuation">-</span> /root/redis/s2<span class="token punctuation">:</span>/etc/redis</span>
<span class="line">    <span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">&quot;host&quot;</span></span>
<span class="line">    <span class="token key atrule">entrypoint</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;redis-sentinel&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;/etc/redis/sentinel.conf&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--port&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;27002&quot;</span><span class="token punctuation">]</span></span>
<span class="line">  <span class="token key atrule">s3</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis</span>
<span class="line">    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> s3</span>
<span class="line">    <span class="token key atrule">volumes</span><span class="token punctuation">:</span></span>
<span class="line">      <span class="token punctuation">-</span> /root/redis/s3<span class="token punctuation">:</span>/etc/redis</span>
<span class="line">    <span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">&quot;host&quot;</span></span>
<span class="line">    <span class="token key atrule">entrypoint</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;redis-sentinel&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;/etc/redis/sentinel.conf&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--port&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;27003&quot;</span><span class="token punctuation">]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接运行命令，启动集群：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">docker-compose</span> up <span class="token parameter variable">-d</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>运行结果：</p><p><img src="`+h+`" alt="image-20250624163402019"></p><p>我们以s1节点为例，查看其运行日志：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token comment"># Sentinel ID is 8e91bd24ea8e5eb2aee38f1cf796dcb26bb88acf</span></span>
<span class="line"><span class="token comment"># +monitor master hmaster 192.168.150.101 7001 quorum 2</span></span>
<span class="line">* +slave slave <span class="token number">192.168</span>.150.101:7003 <span class="token number">192.168</span>.150.101 <span class="token number">7003</span> @ hmaster <span class="token number">192.168</span>.150.101 <span class="token number">7001</span></span>
<span class="line">* +sentinel sentinel 5bafeb97fc16a82b431c339f67b015a51dad5e4f <span class="token number">192.168</span>.150.101 <span class="token number">27002</span> @ hmaster <span class="token number">192.168</span>.150.101 <span class="token number">7001</span></span>
<span class="line">* +sentinel sentinel 56546568a2f7977da36abd3d2d7324c6c3f06b8d <span class="token number">192.168</span>.150.101 <span class="token number">27003</span> @ hmaster <span class="token number">192.168</span>.150.101 <span class="token number">7001</span></span>
<span class="line">* +slave slave <span class="token number">192.168</span>.150.101:7002 <span class="token number">192.168</span>.150.101 <span class="token number">7002</span> @ hmaster <span class="token number">192.168</span>.150.101 <span class="token number">7001</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到<code>sentinel</code>已经联系到了<code>7001</code>这个节点，并且与其它几个哨兵也建立了链接。哨兵信息如下：</p><ul><li><code>27001</code>：<code>Sentinel ID</code>是<code>8e91bd24ea8e5eb2aee38f1cf796dcb26bb88acf</code></li><li><code>27002</code>：<code>Sentinel ID</code>是<code>5bafeb97fc16a82b431c339f67b015a51dad5e4f</code></li><li><code>27003</code>：<code>Sentinel ID</code>是<code>56546568a2f7977da36abd3d2d7324c6c3f06b8d</code></li></ul><h2 id="_3-演示-failover" tabindex="-1"><a class="header-anchor" href="#_3-演示-failover"><span>3 演示 failover</span></a></h2><p>接下来，我们演示一下当主节点故障时，哨兵是如何完成集群故障恢复（failover）的。</p><p>我们连接<code>7001</code>这个<code>master</code>节点，然后通过命令让其休眠60秒，模拟宕机：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token comment"># 连接7001这个master节点，通过sleep模拟服务宕机，60秒后自动恢复</span></span>
<span class="line"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> r1 redis-cli <span class="token parameter variable">-p</span> <span class="token number">7001</span> DEBUG <span class="token function">sleep</span> <span class="token number">60</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>稍微等待一段时间后，会发现sentinel节点触发了<code>failover</code>：</p><p><img src="`+f+`" alt="image-20250624163437281"></p><h2 id="_4-总结" tabindex="-1"><a class="header-anchor" href="#_4-总结"><span>4 总结</span></a></h2><p>Sentinel的三个作用是什么？</p><ul><li>集群监控</li><li>故障恢复</li><li>状态通知</li></ul><p>Sentinel如何判断一个redis实例是否健康？</p><ul><li>每隔1秒发送一次ping命令，如果超过一定时间没有相向则认为是主观下线（<code>sdown</code>）</li><li>如果大多数sentinel都认为实例主观下线，则判定服务客观下线（<code>odown</code>）</li></ul><p>故障转移步骤有哪些？</p><ul><li>首先要在<code>sentinel</code>中选出一个<code>leader</code>，由leader执行<code>failover</code></li><li>选定一个<code>slave</code>作为新的<code>master</code>，执行<code>slaveof noone</code>，切换到master模式</li><li>然后让所有节点都执行<code>slaveof</code> 新master</li><li>修改故障节点配置，添加<code>slaveof</code> 新master</li></ul><p>sentinel选举leader的依据是什么？</p><ul><li>票数超过sentinel节点数量1半</li><li>票数超过quorum数量</li><li>一般情况下最先发起failover的节点会当选</li></ul><p>sentinel从slave中选取master的依据是什么？</p><ul><li>首先会判断slave节点与master节点断开时间长短，如果超过<code>down-after-milliseconds\`\` * 10</code>则会排除该slave节点</li><li>然后判断slave节点的<code>slave-priority</code>值，越小优先级越高，如果是0则永不参与选举（默认都是1）。</li><li>如果<code>slave-prority</code>一样，则判断slave节点的<code>offset</code>值，越大说明数据越新，优先级越高</li><li>最后是判断slave节点的<code>run_id</code>大小，越小优先级越高（<code>通过info server可以查看run_id</code>）。</li></ul><h2 id="_5-redistemplate-连接哨兵集群-自学" tabindex="-1"><a class="header-anchor" href="#_5-redistemplate-连接哨兵集群-自学"><span>5 RedisTemplate 连接哨兵集群 (自学)</span></a></h2><p>分为三步：</p><ul><li>1）引入依赖</li><li>2）配置哨兵地址</li><li>3）配置读写分离</li></ul><h3 id="_5-1-引入依赖" tabindex="-1"><a class="header-anchor" href="#_5-1-引入依赖"><span>5.1 引入依赖</span></a></h3><p>就是SpringDataRedis的依赖：</p><div class="language-xml line-numbers-mode" data-highlighter="prismjs" data-ext="xml" data-title="xml"><pre><code><span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span></span>
<span class="line">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span></span>
<span class="line">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5-2-配置哨兵地址" tabindex="-1"><a class="header-anchor" href="#_5-2-配置哨兵地址"><span>5.2 配置哨兵地址</span></a></h3><p>连接哨兵集群与传统单点模式不同，不再需要设置每一个redis的地址，而是直接指定哨兵地址：</p><div class="language-yaml line-numbers-mode" data-highlighter="prismjs" data-ext="yml" data-title="yml"><pre><code><span class="line"><span class="token key atrule">spring</span><span class="token punctuation">:</span></span>
<span class="line">  <span class="token key atrule">redis</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token key atrule">sentinel</span><span class="token punctuation">:</span></span>
<span class="line">      <span class="token key atrule">master</span><span class="token punctuation">:</span> hmaster <span class="token comment"># 集群名</span></span>
<span class="line">      <span class="token key atrule">nodes</span><span class="token punctuation">:</span> <span class="token comment"># 哨兵地址列表</span></span>
<span class="line">        <span class="token punctuation">-</span> 192.168.150.101<span class="token punctuation">:</span><span class="token number">27001</span></span>
<span class="line">        <span class="token punctuation">-</span> 192.168.150.101<span class="token punctuation">:</span><span class="token number">27002</span></span>
<span class="line">        <span class="token punctuation">-</span> 192.168.150.101<span class="token punctuation">:</span><span class="token number">27003</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5-3-配置读写分离" tabindex="-1"><a class="header-anchor" href="#_5-3-配置读写分离"><span>5.3 配置读写分离</span></a></h3><p>最后，还要配置读写分离，让java客户端将写请求发送到master节点，读请求发送到slave节点。定义一个bean即可：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Bean</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token class-name">LettuceClientConfigurationBuilderCustomizer</span> <span class="token function">clientConfigurationBuilderCustomizer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> clientConfigurationBuilder <span class="token operator">-&gt;</span> clientConfigurationBuilder<span class="token punctuation">.</span><span class="token function">readFrom</span><span class="token punctuation">(</span><span class="token class-name">ReadFrom</span><span class="token punctuation">.</span><span class="token constant">REPLICA_PREFERRED</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个bean中配置的就是读写策略，包括四种：</p><ul><li><code>MASTER</code>：从主节点读取</li><li><code>MASTER_PREFERRED</code>：优先从<code>master</code>节点读取，<code>master</code>不可用才读取<code>slave</code></li><li><code>REPLICA</code>：从<code>slave</code>节点读取</li><li><code>REPLICA_PREFERRED</code>：优先从<code>slave</code>节点读取，所有的<code>slave</code>都不可用才读取<code>master</code></li></ul>`,76))])}const R=t(_,[["render",y]]),S=JSON.parse('{"path":"/docs/Java/Heima/Microservices/Day10_RedisInterview/2-RedisInterview.html","title":"Redis哨兵","lang":"en-US","frontmatter":{"title":"Redis哨兵","date":"2025/03/06"},"headers":[{"level":2,"title":"1 哨兵工作原理","slug":"_1-哨兵工作原理","link":"#_1-哨兵工作原理","children":[{"level":3,"title":"1.1 哨兵作用","slug":"_1-1-哨兵作用","link":"#_1-1-哨兵作用","children":[]},{"level":3,"title":"1.2 状态监控","slug":"_1-2-状态监控","link":"#_1-2-状态监控","children":[]},{"level":3,"title":"1.3 选举 leader","slug":"_1-3-选举-leader","link":"#_1-3-选举-leader","children":[]},{"level":3,"title":"1.4 failover","slug":"_1-4-failover","link":"#_1-4-failover","children":[]}]},{"level":2,"title":"2 搭建哨兵集群","slug":"_2-搭建哨兵集群","link":"#_2-搭建哨兵集群","children":[]},{"level":2,"title":"3 演示 failover","slug":"_3-演示-failover","link":"#_3-演示-failover","children":[]},{"level":2,"title":"4 总结","slug":"_4-总结","link":"#_4-总结","children":[]},{"level":2,"title":"5 RedisTemplate 连接哨兵集群 (自学)","slug":"_5-redistemplate-连接哨兵集群-自学","link":"#_5-redistemplate-连接哨兵集群-自学","children":[{"level":3,"title":"5.1 引入依赖","slug":"_5-1-引入依赖","link":"#_5-1-引入依赖","children":[]},{"level":3,"title":"5.2 配置哨兵地址","slug":"_5-2-配置哨兵地址","link":"#_5-2-配置哨兵地址","children":[]},{"level":3,"title":"5.3 配置读写分离","slug":"_5-3-配置读写分离","link":"#_5-3-配置读写分离","children":[]}]}],"filePathRelative":"docs/Java/Heima/Microservices/Day10_RedisInterview/2-RedisInterview.md","git":{"createdTime":1741251281000,"updatedTime":1750756522000,"contributors":[{"name":"lixuan","email":"2789968443@qq.com","commits":2}]}}');export{R as comp,S as data};
