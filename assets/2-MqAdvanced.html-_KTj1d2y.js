import{_ as n,c as s,b as e,o as t}from"./app-CezBFXHK.js";const l="/assets/image-20250624122308398-DeMOcTJz.png",p="/assets/image-20250624122354190-Wf4VPFsz.png",i="/assets/image-20250624122456494-4wU5fr_J.png",c="/assets/-175073913393915-BjXxX62e.png",o="/assets/image-20250624122622760-B_wI8F8q.png",u="/assets/image-20250624122645365-kA1RPLqz.png",d={};function r(m,a){return t(),s("div",null,a[0]||(a[0]=[e('<p><img src="https://bizhi1.com/wp-content/uploads/2024/11/kitten-3840x2160-adorable-minimalist-cute-charming-26365.jpg" alt="小猫 可爱的 极简主义者 可爱的 迷人 纯色背景"></p><div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>1 数据持久化</p><p>2 LazyQueue</p></div><p>消息到达MQ以后，如果MQ不能及时保存，也会导致消息丢失，所以MQ的可靠性也非常重要。</p><h2 id="_1-数据持久化" tabindex="-1"><a class="header-anchor" href="#_1-数据持久化"><span>1 数据持久化</span></a></h2><p>为了提升性能，默认情况下MQ的数据都是在内存存储的临时数据，重启后就会消失。为了保证数据的可靠性，必须配置数据持久化，包括：</p><ul><li>交换机持久化</li><li>队列持久化</li><li>消息持久化</li></ul><p>我们以控制台界面为例来说明。</p><h3 id="_1-1-交换机持久化" tabindex="-1"><a class="header-anchor" href="#_1-1-交换机持久化"><span>1.1 交换机持久化</span></a></h3><p>在控制台的<code>Exchanges</code>页面，添加交换机时可以配置交换机的<code>Durability</code>参数：</p><p><img src="'+l+'" alt="image-20250624122308398"></p><p>设置为<code>Durable</code>就是持久化模式，<code>Transient</code>就是临时模式。</p><h3 id="_1-2-队列持久化" tabindex="-1"><a class="header-anchor" href="#_1-2-队列持久化"><span>1.2 队列持久化</span></a></h3><p>在控制台的Queues页面，添加队列时，同样可以配置队列的<code>Durability</code>参数：</p><p><img src="'+p+'" alt="image-20250624122354190"></p><p>除了持久化以外，你可以看到队列还有很多其它参数，有一些我们会在后期学习。</p><h3 id="_1-3-消息持久化" tabindex="-1"><a class="header-anchor" href="#_1-3-消息持久化"><span>1.3 消息持久化</span></a></h3><p>在控制台发送消息的时候，可以添加很多参数，而消息的持久化是要配置一个<code>properties</code>：</p><p><img src="'+i+'" alt="image-20250624122456494"></p><p><strong>说明</strong>：在开启持久化机制以后，如果同时还开启了生产者确认，那么MQ会在消息持久化以后才发送ACK回执，进一步确保消息的可靠性。</p><p>不过出于性能考虑，为了减少IO次数，发送到MQ的消息并不是逐条持久化到数据库的，而是每隔一段时间批量持久化。一般间隔在100毫秒左右，这就会导致ACK有一定的延迟，因此建议生产者确认全部采用异步方式。</p><h2 id="_2-lazyqueue" tabindex="-1"><a class="header-anchor" href="#_2-lazyqueue"><span>2 LazyQueue</span></a></h2><p>在默认情况下，RabbitMQ会将接收到的信息保存在内存中以降低消息收发的延迟。但在某些特殊情况下，这会导致消息积压，比如：</p><ul><li>消费者宕机或出现网络故障</li><li>消息发送量激增，超过了消费者处理速度</li><li>消费者处理业务发生阻塞</li></ul><p>一旦出现消息堆积问题，RabbitMQ的内存占用就会越来越高，直到触发内存预警上限。此时RabbitMQ会将内存消息刷到磁盘上，这个行为成为<code>PageOut</code>. <code>PageOut</code>会耗费一段时间，并且会阻塞队列进程。因此在这个过程中RabbitMQ不会再处理新的消息，生产者的所有请求都会被阻塞。</p><p>为了解决这个问题，从RabbitMQ的3.6.0版本开始，就增加了Lazy Queues的模式，也就是惰性队列。惰性队列的特征如下：</p><ul><li>接收到消息后直接存入磁盘而非内存</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存（也就是懒加载）</li><li>支持数百万条的消息存储</li></ul><p>而在3.12版本之后，LazyQueue已经成为所有队列的默认格式。因此官方推荐升级MQ为3.12版本或者所有队列都设置为LazyQueue模式。</p><h3 id="_2-1-控制台配置-lazy-模式" tabindex="-1"><a class="header-anchor" href="#_2-1-控制台配置-lazy-模式"><span>2.1. 控制台配置 Lazy 模式</span></a></h3><p>在添加队列的时候，添加<code>x-queue-mod=lazy</code>参数即可设置队列为Lazy模式：</p><p><img src="'+c+`" alt="img"></p><h3 id="_2-2-代码配置-lazy-模式" tabindex="-1"><a class="header-anchor" href="#_2-2-代码配置-lazy-模式"><span>2.2. 代码配置 Lazy 模式</span></a></h3><p>在利用SpringAMQP声明队列的时候，添加<code>x-queue-mod=lazy</code>参数也可设置队列为Lazy模式：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Bean</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">lazyQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token class-name">QueueBuilder</span></span>
<span class="line">            <span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span><span class="token string">&quot;lazy.queue&quot;</span><span class="token punctuation">)</span></span>
<span class="line">            <span class="token punctuation">.</span><span class="token function">lazy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 开启Lazy模式</span></span>
<span class="line">            <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里是通过<code>QueueBuilder</code>的<code>lazy()</code>函数配置Lazy模式，底层源码如下：</p><p><img src="`+o+`" alt="image-20250624122622760"></p><p>当然，我们也可以基于注解来声明队列并设置为Lazy模式：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queuesToDeclare <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">(</span></span>
<span class="line">        name <span class="token operator">=</span> <span class="token string">&quot;lazy.queue&quot;</span><span class="token punctuation">,</span></span>
<span class="line">        durable <span class="token operator">=</span> <span class="token string">&quot;true&quot;</span><span class="token punctuation">,</span></span>
<span class="line">        arguments <span class="token operator">=</span> <span class="token annotation punctuation">@Argument</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;x-queue-mode&quot;</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">&quot;lazy&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenLazyQueue</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;接收到 lazy.queue的消息：{}&quot;</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-3-更新已有队列为-lazy-模式" tabindex="-1"><a class="header-anchor" href="#_2-3-更新已有队列为-lazy-模式"><span>2.3. 更新已有队列为 lazy 模式</span></a></h3><p>对于已经存在的队列，也可以配置为lazy模式，但是要通过设置policy实现。</p><p>可以基于命令行设置policy：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">rabbitmqctl set_policy Lazy <span class="token string">&quot;^lazy-queue$&quot;</span> <span class="token string">&#39;{&quot;queue-mode&quot;:&quot;lazy&quot;}&#39;</span> --apply-to queues  </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>命令解读：</p><ul><li><code>rabbitmqctl</code> ：RabbitMQ的命令行工具</li><li><code>set_policy</code> ：添加一个策略</li><li><code>Lazy</code> ：策略名称，可以自定义</li><li><code>&quot;^lazy-queue$&quot;</code> ：用正则表达式匹配队列的名字</li><li><code>&#39;{&quot;queue-mode&quot;:&quot;lazy&quot;}&#39;</code> ：设置队列模式为lazy模式</li><li><code>--apply-to queues</code>：策略的作用对象，是所有的队列</li></ul><p>当然，也可以在控制台配置policy，进入在控制台的<code>Admin</code>页面，点击<code>Policies</code>，即可添加配置：</p><p><img src="`+u+'" alt="image-20250624122645365"></p>',45)]))}const h=n(d,[["render",r]]),v=JSON.parse('{"path":"/docs/Java/Heima/Microservices/Day07_MqAdvanced/2-MqAdvanced.html","title":"MQ的可靠性","lang":"en-US","frontmatter":{"title":"MQ的可靠性","date":"2025/03/06"},"headers":[{"level":2,"title":"1 数据持久化","slug":"_1-数据持久化","link":"#_1-数据持久化","children":[{"level":3,"title":"1.1 交换机持久化","slug":"_1-1-交换机持久化","link":"#_1-1-交换机持久化","children":[]},{"level":3,"title":"1.2 队列持久化","slug":"_1-2-队列持久化","link":"#_1-2-队列持久化","children":[]},{"level":3,"title":"1.3 消息持久化","slug":"_1-3-消息持久化","link":"#_1-3-消息持久化","children":[]}]},{"level":2,"title":"2 LazyQueue","slug":"_2-lazyqueue","link":"#_2-lazyqueue","children":[{"level":3,"title":"2.1. 控制台配置 Lazy 模式","slug":"_2-1-控制台配置-lazy-模式","link":"#_2-1-控制台配置-lazy-模式","children":[]},{"level":3,"title":"2.2. 代码配置 Lazy 模式","slug":"_2-2-代码配置-lazy-模式","link":"#_2-2-代码配置-lazy-模式","children":[]},{"level":3,"title":"2.3. 更新已有队列为 lazy 模式","slug":"_2-3-更新已有队列为-lazy-模式","link":"#_2-3-更新已有队列为-lazy-模式","children":[]}]}],"filePathRelative":"docs/Java/Heima/Microservices/Day07_MqAdvanced/2-MqAdvanced.md","git":{"createdTime":1741251281000,"updatedTime":1750752221000,"contributors":[{"name":"lixuan","email":"2789968443@qq.com","commits":2}]}}');export{h as comp,v as data};
