import{_ as r,c as p,b as s,a as i,d as l,e as n,r as d,o as a}from"./app-DPwDFWa6.js";const o="/assets/1653129590210-B-EWGMkH.png",c="/assets/1653130457771-CIBqll9_.png",g="/assets/1653130475979-B9SNdBdD.png",_="/assets/1653130858066-BmDh66cw.png",h="/assets/1653132073570-4E8LKixm.png",u="/assets/1653132098823-DEozzwnS.png",m="/assets/1653132410073-Dk-oeAx_.png",R="/assets/1653132740637-DcqrhrB5.png",k={},f={href:"https://cloud.tencent.com/developer/article/1039000",target:"_blank",rel:"noopener noreferrer"};function v(w,e){const t=d("ExternalLinkIcon");return a(),p("div",null,[e[4]||(e[4]=s('<p><img src="https://bizhi1.com/wp-content/uploads/2024/07/itachi-uchiha-sharingan-dark-desktop-wallpaper-small.jpg" alt="宇智波鼬 黑暗 桌面壁纸"></p><div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>① 服务器端优化-持久化配置</p><p>② 服务器端优化-慢查询优化</p><p>③ 服务器端优化-命令及安全配置</p><p>④ 服务器端优化-Redis内存划分和内存配置</p><p>⑤ 服务器端集群优化-集群还是主从</p></div><h2 id="_1-服务器端优化-持久化配置" tabindex="-1"><a class="header-anchor" href="#_1-服务器端优化-持久化配置"><span>① 服务器端优化-持久化配置</span></a></h2><p>Redis的持久化虽然可以保证数据安全，但也会带来很多额外的开销，因此持久化请遵循下列建议：</p><ul><li>用来做缓存的Redis实例尽量不要开启持久化功能</li><li>建议关闭RDB持久化功能，使用AOF持久化</li><li>利用脚本定期在slave节点做RDB，实现数据备份</li><li>设置合理的rewrite阈值，避免频繁的bgrewrite</li><li>配置no-appendfsync-on-rewrite = yes，禁止在rewrite期间做aof，避免因AOF引起的阻塞</li><li>部署有关建议： <ul><li>Redis实例的物理机要预留足够内存，应对fork和rewrite</li><li>单个Redis实例内存上限不要太大，例如4G或8G。可以加快fork的速度、减少主从同步、数据迁移压力</li><li>不要与CPU密集型应用部署在一起</li><li>不要与高硬盘负载应用一起部署。例如：数据库、消息队列</li></ul></li></ul><h2 id="_2-服务器端优化-慢查询优化" tabindex="-1"><a class="header-anchor" href="#_2-服务器端优化-慢查询优化"><span>② 服务器端优化-慢查询优化</span></a></h2><h3 id="_2-1-什么是慢查询" tabindex="-1"><a class="header-anchor" href="#_2-1-什么是慢查询"><span>2.1 什么是慢查询</span></a></h3><p>并不是很慢的查询才是慢查询，而是：在Redis执行时耗时超过某个阈值的命令，称为慢查询。</p><p>慢查询的危害：由于Redis是单线程的，所以当客户端发出指令后，他们都会进入到redis底层的queue来执行，如果此时有一些慢查询的数据，就会导致大量请求阻塞，从而引起报错，所以我们需要解决慢查询问题。</p><p><img src="'+o+'" alt="1653129590210"></p><p>慢查询的阈值可以通过配置指定：</p><p>slowlog-log-slower-than：慢查询阈值，单位是微秒。默认是10000，建议1000</p><p>慢查询会被放入慢查询日志中，日志的长度有上限，可以通过配置指定：</p><p>slowlog-max-len：慢查询日志（本质是一个队列）的长度。默认是128，建议1000</p><p><img src="'+c+'" alt="1653130457771"></p><p>修改这两个配置可以使用：config set命令：</p><p><img src="'+g+'" alt="1653130475979"></p><h3 id="_2-2-如何查看慢查询" tabindex="-1"><a class="header-anchor" href="#_2-2-如何查看慢查询"><span>2.2 如何查看慢查询</span></a></h3><p>知道了以上内容之后，那么咱们如何去查看慢查询日志列表呢：</p><ul><li>slowlog len：查询慢查询日志长度</li><li>slowlog get [n]：读取n条慢查询日志</li><li>slowlog reset：清空慢查询列表</li></ul><p><img src="'+_+'" alt="1653130858066"></p><h2 id="_3-服务器端优化-命令及安全配置" tabindex="-1"><a class="header-anchor" href="#_3-服务器端优化-命令及安全配置"><span>③ 服务器端优化-命令及安全配置</span></a></h2><p>安全可以说是服务器端一个非常重要的话题，如果安全出现了问题，那么一旦这个漏洞被一些坏人知道了之后，并且进行攻击，那么这就会给咱们的系统带来很多的损失，所以我们这节课就来解决这个问题。</p>',23)),i("p",null,[e[1]||(e[1]=l("Redis会绑定在0.0.0.0:6379，这样将会将Redis服务暴露到公网上，而Redis如果没有做身份认证，会出现严重的安全漏洞.")),e[2]||(e[2]=i("br",null,null,-1)),e[3]||(e[3]=l(" 漏洞重现方式：")),i("a",f,[e[0]||(e[0]=l("https://cloud.tencent.com/developer/article/1039000")),n(t)])]),e[5]||(e[5]=s('<p>为什么会出现不需要密码也能够登录呢，主要是Redis考虑到每次登录都比较麻烦，所以Redis就有一种ssh免秘钥登录的方式，生成一对公钥和私钥，私钥放在本地，公钥放在redis端，当我们登录时服务器，再登录时候，他会去解析公钥和私钥，如果没有问题，则不需要利用redis的登录也能访问，这种做法本身也很常见，但是这里有一个前提，前提就是公钥必须保存在服务器上，才行，但是Redis的漏洞在于在不登录的情况下，也能把秘钥送到Linux服务器，从而产生漏洞</p><p>漏洞出现的核心的原因有以下几点：</p><ul><li>Redis未设置密码</li><li>利用了Redis的config set命令动态修改Redis配置</li><li>使用了Root账号权限启动Redis</li></ul><p>所以：如何解决呢？我们可以采用如下几种方案</p><p>为了避免这样的漏洞，这里给出一些建议：</p><ul><li>Redis一定要设置密码</li><li>禁止线上使用下面命令：keys、flushall、flushdb、config set等命令。可以利用rename-command禁用。</li><li>bind：限制网卡，禁止外网网卡访问</li><li>开启防火墙</li><li>不要使用Root账户启动Redis</li><li>尽量不是有默认的端口</li></ul><h2 id="_4-服务器端优化-redis内存划分和内存配置" tabindex="-1"><a class="header-anchor" href="#_4-服务器端优化-redis内存划分和内存配置"><span>④ 服务器端优化-Redis内存划分和内存配置</span></a></h2><p>当Redis内存不足时，可能导致Key频繁被删除、响应时间变长、QPS不稳定等问题。当内存使用率达到90%以上时就需要我们警惕，并快速定位到内存占用的原因。</p><p><strong>有关碎片问题分析</strong></p><p>Redis底层分配并不是这个key有多大，他就会分配多大，而是有他自己的分配策略，比如8,16,20等等，假定当前key只需要10个字节，此时分配8肯定不够，那么他就会分配16个字节，多出来的6个字节就不能被使用，这就是我们常说的 碎片问题</p><p><strong>进程内存问题分析：</strong></p><p>这片内存，通常我们都可以忽略不计</p><p><strong>缓冲区内存问题分析：</strong></p><p>一般包括客户端缓冲区、AOF缓冲区、复制缓冲区等。客户端缓冲区又包括输入缓冲区和输出缓冲区两种。这部分内存占用波动较大，所以这片内存也是我们需要重点分析的内存问题。</p><table><thead><tr><th><strong>内存占用</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>数据内存</td><td>是Redis最主要的部分，存储Redis的键值信息。主要问题是BigKey问题、内存碎片问题</td></tr><tr><td>进程内存</td><td>Redis主进程本身运⾏肯定需要占⽤内存，如代码、常量池等等；这部分内存⼤约⼏兆，在⼤多数⽣产环境中与Redis数据占⽤的内存相⽐可以忽略。</td></tr><tr><td>缓冲区内存</td><td>一般包括客户端缓冲区、AOF缓冲区、复制缓冲区等。客户端缓冲区又包括输入缓冲区和输出缓冲区两种。这部分内存占用波动较大，不当使用BigKey，可能导致内存溢出。</td></tr></tbody></table><p>于是我们就需要通过一些命令，可以查看到Redis目前的内存分配状态：</p><ul><li>info memory：查看内存分配的情况</li></ul><p><img src="'+h+'" alt="1653132073570"></p><ul><li>memory xxx：查看key的主要占用情况</li></ul><p><img src="'+u+'" alt="1653132098823"></p><p>接下来我们看到了这些配置，最关键的缓存区内存如何定位和解决呢？</p><p>内存缓冲区常见的有三种：</p><ul><li>复制缓冲区：主从复制的repl_backlog_buf，如果太小可能导致频繁的全量复制，影响性能。通过replbacklog-size来设置，默认1mb</li><li>AOF缓冲区：AOF刷盘之前的缓存区域，AOF执行rewrite的缓冲区。无法设置容量上限</li><li>客户端缓冲区：分为输入缓冲区和输出缓冲区，输入缓冲区最大1G且不能设置。输出缓冲区可以设置</li></ul><p>以上复制缓冲区和AOF缓冲区 不会有问题，最关键就是客户端缓冲区的问题</p><p>客户端缓冲区：指的就是我们发送命令时，客户端用来缓存命令的一个缓冲区，也就是我们向redis输入数据的输入端缓冲区和redis向客户端返回数据的响应缓存区，输入缓冲区最大1G且不能设置，所以这一块我们根本不用担心，如果超过了这个空间，redis会直接断开，因为本来此时此刻就代表着redis处理不过来了，我们需要担心的就是输出端缓冲区</p><p><img src="'+m+'" alt="1653132410073"></p><p>我们在使用redis过程中，处理大量的big value，那么会导致我们的输出结果过多，如果输出缓存区过大，会导致redis直接断开，而默认配置的情况下， 其实他是没有大小的，这就比较坑了，内存可能一下子被占满，会直接导致咱们的redis断开，所以解决方案有两个</p><p>1、设置一个大小</p><p>2、增加我们带宽的大小，避免我们出现大量数据从而直接超过了redis的承受能力</p><h2 id="_5-服务器端集群优化-集群还是主从" tabindex="-1"><a class="header-anchor" href="#_5-服务器端集群优化-集群还是主从"><span>⑤ 服务器端集群优化-集群还是主从</span></a></h2><p>集群虽然具备高可用特性，能实现自动故障恢复，但是如果使用不当，也会存在一些问题：</p><ul><li>集群完整性问题</li><li>集群带宽问题</li><li>数据倾斜问题</li><li>客户端性能问题</li><li>命令的集群兼容性问题</li><li>lua和事务问题</li></ul><p><strong>问题1、在Redis的默认配置中，如果发现任意一个插槽不可用，则整个集群都会停止对外服务：</strong></p><p>大家可以设想一下，如果有几个slot不能使用，那么此时整个集群都不能用了，我们在开发中，其实最重要的是可用性，所以需要把如下配置修改成no，即有slot不能使用时，我们的redis集群还是可以对外提供服务</p><p><img src="'+R+'" alt="1653132740637"></p><p><strong>问题2、集群带宽问题</strong></p><p>集群节点之间会不断的互相Ping来确定集群中其它节点的状态。每次Ping携带的信息至少包括：</p><ul><li>插槽信息</li><li>集群状态信息</li></ul><p>集群中节点越多，集群状态信息数据量也越大，10个节点的相关信息可能达到1kb，此时每次集群互通需要的带宽会非常高，这样会导致集群中大量的带宽都会被ping信息所占用，这是一个非常可怕的问题，所以我们需要去解决这样的问题</p><p><strong>解决途径：</strong></p><ul><li>避免大集群，集群节点数不要太多，最好少于1000，如果业务庞大，则建立多个集群。</li><li>避免在单个物理机中运行太多Redis实例</li><li>配置合适的cluster-node-timeout值</li></ul><p><strong>问题3、命令的集群兼容性问题</strong></p><p>有关这个问题咱们已经探讨过了，当我们使用批处理的命令时，redis要求我们的key必须落在相同的slot上，然后大量的key同时操作时，是无法完成的，所以客户端必须要对这样的数据进行处理，这些方案我们之前已经探讨过了，所以不再这个地方赘述了。</p><p><strong>问题4、lua和事务的问题</strong></p><p>lua和事务都是要保证原子性问题，如果你的key不在一个节点，那么是无法保证lua的执行和事务的特性的，所以在集群模式是没有办法执行lua和事务的</p><p><strong>那我们到底是集群还是主从</strong></p><p>单体Redis（主从Redis）已经能达到万级别的QPS，并且也具备很强的高可用特性。如果主从能满足业务需求的情况下，所以如果不是在万不得已的情况下，尽量不搭建Redis集群</p>',47))])}const b=r(k,[["render",v]]),y=JSON.parse('{"path":"/docs/Middleware/Redis/Redis_Heima/3_Redis_Advanced/3_Redis_Advanced_Practice/3-Redis_Advanced_Practice.html","title":"Redis实践(二)","lang":"en-US","frontmatter":{"title":"Redis实践(二)","date":"2025/06/19"},"headers":[{"level":2,"title":"① 服务器端优化-持久化配置","slug":"_1-服务器端优化-持久化配置","link":"#_1-服务器端优化-持久化配置","children":[]},{"level":2,"title":"② 服务器端优化-慢查询优化","slug":"_2-服务器端优化-慢查询优化","link":"#_2-服务器端优化-慢查询优化","children":[{"level":3,"title":"2.1 什么是慢查询","slug":"_2-1-什么是慢查询","link":"#_2-1-什么是慢查询","children":[]},{"level":3,"title":"2.2 如何查看慢查询","slug":"_2-2-如何查看慢查询","link":"#_2-2-如何查看慢查询","children":[]}]},{"level":2,"title":"③ 服务器端优化-命令及安全配置","slug":"_3-服务器端优化-命令及安全配置","link":"#_3-服务器端优化-命令及安全配置","children":[]},{"level":2,"title":"④ 服务器端优化-Redis内存划分和内存配置","slug":"_4-服务器端优化-redis内存划分和内存配置","link":"#_4-服务器端优化-redis内存划分和内存配置","children":[]},{"level":2,"title":"⑤ 服务器端集群优化-集群还是主从","slug":"_5-服务器端集群优化-集群还是主从","link":"#_5-服务器端集群优化-集群还是主从","children":[]}],"filePathRelative":"docs/Middleware/Redis/Redis_Heima/3_Redis_Advanced/3_Redis_Advanced_Practice/3-Redis_Advanced_Practice.md","git":{"createdTime":1750319780000,"updatedTime":1750319780000,"contributors":[{"name":"lixuan","email":"2789968443@qq.com","commits":1}]}}');export{b as comp,y as data};
