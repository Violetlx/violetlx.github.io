import{_ as t,c as i,b as a,a as e,d as n,e as p,r,o}from"./app-DPwDFWa6.js";const c="/assets/image-20210725154528072-BgvUmRou.png",d="/assets/image-20210725154632354-CeOT8mcs.png",u="/assets/image-20210725154816841-Bq-eAVYI.png",m="/assets/image-20210725152052501-C8jwnLiw.png",v="/assets/image-20210725155124958-BI0ALJlQ.png",g={},k={href:"http://xn--Redis-2o3nn90k.md",target:"_blank",rel:"noopener noreferrer"};function h(_,s){const l=r("ExternalLinkIcon");return o(),i("div",null,[s[3]||(s[3]=a('<p><img src="https://bizhi1.com/wp-content/uploads/2024/08/blonde-anime-girl-sky-desktop-wallpaper-4k-small.jpg" alt="动漫女孩天空桌面壁纸"></p><div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>① 哨兵原理</p><p>② 搭建哨兵集群</p><p>③ RedisTemplate</p></div><h2 id="_1-哨兵原理" tabindex="-1"><a class="header-anchor" href="#_1-哨兵原理"><span>① 哨兵原理</span></a></h2><h3 id="_1-1-集群结构和作用" tabindex="-1"><a class="header-anchor" href="#_1-1-集群结构和作用"><span>1.1.集群结构和作用</span></a></h3><p>哨兵的结构如图：</p><p><img src="'+c+'" alt="image-20210725154528072"></p><p>哨兵的作用如下：</p><ul><li><strong>监控</strong>：Sentinel 会不断检查您的master和slave是否按预期工作</li><li><strong>自动故障恢复</strong>：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主</li><li><strong>通知</strong>：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</li></ul><h3 id="_1-2-集群监控原理" tabindex="-1"><a class="header-anchor" href="#_1-2-集群监控原理"><span>1.2.集群监控原理</span></a></h3><p>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：</p><p>•主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</p><p>•客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>。quorum值最好超过Sentinel实例数量的一半。</p><p><img src="'+d+'" alt="image-20210725154632354"></p><h3 id="_1-3-集群故障恢复原理" tabindex="-1"><a class="header-anchor" href="#_1-3-集群故障恢复原理"><span>1.3.集群故障恢复原理</span></a></h3><p>一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：</p><ul><li>首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点</li><li>然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举</li><li>如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</li><li>最后是判断slave节点的运行id大小，越小优先级越高。</li></ul><p>当选出一个新的master后，该如何实现切换呢？</p><p>流程如下：</p><ul><li>sentinel给备选的slave1节点发送slaveof no one命令，让该节点成为master</li><li>sentinel给所有其它slave发送slaveof 192.168.150.101 7002 命令，让这些slave成为新master的从节点，开始从新的master上同步数据。</li><li>最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点</li></ul><p><img src="'+u+'" alt="image-20210725154816841"></p><h3 id="_1-4-小结" tabindex="-1"><a class="header-anchor" href="#_1-4-小结"><span>1.4.小结</span></a></h3><p>Sentinel的三个作用是什么？</p><ul><li>监控</li><li>故障转移</li><li>通知</li></ul><p>Sentinel如何判断一个redis实例是否健康？</p><ul><li>每隔1秒发送一次ping命令，如果超过一定时间没有相向则认为是主观下线</li><li>如果大多数sentinel都认为实例主观下线，则判定服务下线</li></ul><p>故障转移步骤有哪些？</p><ul><li>首先选定一个slave作为新的master，执行slaveof no one</li><li>然后让所有节点都执行slaveof 新master</li><li>修改故障节点配置，添加slaveof 新master</li></ul><h2 id="_2-搭建哨兵集群" tabindex="-1"><a class="header-anchor" href="#_2-搭建哨兵集群"><span>② 搭建哨兵集群</span></a></h2>',28)),e("p",null,[s[1]||(s[1]=n("具体搭建流程参考课前资料《")),e("a",k,[s[0]||(s[0]=n("Redis集群.md")),p(l)]),s[2]||(s[2]=n("》："))]),s[4]||(s[4]=a('<p><img src="'+m+'" alt="image-20210725155019276"></p><h2 id="_3-redistemplate" tabindex="-1"><a class="header-anchor" href="#_3-redistemplate"><span>③ RedisTemplate</span></a></h2><p>在Sentinel集群监管下的Redis主从集群，其节点会因为自动故障转移而发生变化，Redis的客户端必须感知这种变化，及时更新连接信息。Spring的RedisTemplate底层利用lettuce实现了节点的感知和自动切换。</p><p>下面，我们通过一个测试来实现RedisTemplate集成哨兵机制。</p><h3 id="_3-1-导入demo工程" tabindex="-1"><a class="header-anchor" href="#_3-1-导入demo工程"><span>3.1.导入Demo工程</span></a></h3><p>首先，我们引入课前资料提供的Demo工程：</p><p><img src="'+v+`" alt="image-20210725155124958"></p><h3 id="_3-2-引入依赖" tabindex="-1"><a class="header-anchor" href="#_3-2-引入依赖"><span>3.2.引入依赖</span></a></h3><p>在项目的pom文件中引入依赖：</p><div class="language-xml line-numbers-mode" data-highlighter="prismjs" data-ext="xml" data-title="xml"><pre><code><span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span></span>
<span class="line">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span></span>
<span class="line">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-3-配置redis地址" tabindex="-1"><a class="header-anchor" href="#_3-3-配置redis地址"><span>3.3.配置Redis地址</span></a></h3><p>然后在配置文件application.yml中指定redis的sentinel相关信息：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line">spring<span class="token operator">:</span></span>
<span class="line">  redis<span class="token operator">:</span></span>
<span class="line">    sentinel<span class="token operator">:</span></span>
<span class="line">      master<span class="token operator">:</span> mymaster</span>
<span class="line">      nodes<span class="token operator">:</span></span>
<span class="line">        <span class="token operator">-</span> <span class="token number">192.168</span><span class="token number">.150</span><span class="token number">.101</span><span class="token operator">:</span><span class="token number">27001</span></span>
<span class="line">        <span class="token operator">-</span> <span class="token number">192.168</span><span class="token number">.150</span><span class="token number">.101</span><span class="token operator">:</span><span class="token number">27002</span></span>
<span class="line">        <span class="token operator">-</span> <span class="token number">192.168</span><span class="token number">.150</span><span class="token number">.101</span><span class="token operator">:</span><span class="token number">27003</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-4-配置读写分离" tabindex="-1"><a class="header-anchor" href="#_3-4-配置读写分离"><span>3.4.配置读写分离</span></a></h3><p>在项目的启动类中，添加一个新的bean：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Bean</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token class-name">LettuceClientConfigurationBuilderCustomizer</span> <span class="token function">clientConfigurationBuilderCustomizer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> clientConfigurationBuilder <span class="token operator">-&gt;</span> clientConfigurationBuilder<span class="token punctuation">.</span><span class="token function">readFrom</span><span class="token punctuation">(</span><span class="token class-name">ReadFrom</span><span class="token punctuation">.</span><span class="token constant">REPLICA_PREFERRED</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个bean中配置的就是读写策略，包括四种：</p><ul><li>MASTER：从主节点读取</li><li>MASTER_PREFERRED：优先从master节点读取，master不可用才读取replica</li><li>REPLICA：从slave（replica）节点读取</li><li>REPLICA _PREFERRED：优先从slave（replica）节点读取，所有的slave都不可用才读取master</li></ul>`,18))])}const R=t(g,[["render",h]]),f=JSON.parse('{"path":"/docs/Middleware/Redis/Redis_Heima/3_Redis_Advanced/1_Redis_Advanced_Distributed/4-Redis_Advanced_Distributed.html","title":"Redis哨兵","lang":"en-US","frontmatter":{"title":"Redis哨兵","date":"2025/06/19"},"headers":[{"level":2,"title":"① 哨兵原理","slug":"_1-哨兵原理","link":"#_1-哨兵原理","children":[{"level":3,"title":"1.1.集群结构和作用","slug":"_1-1-集群结构和作用","link":"#_1-1-集群结构和作用","children":[]},{"level":3,"title":"1.2.集群监控原理","slug":"_1-2-集群监控原理","link":"#_1-2-集群监控原理","children":[]},{"level":3,"title":"1.3.集群故障恢复原理","slug":"_1-3-集群故障恢复原理","link":"#_1-3-集群故障恢复原理","children":[]},{"level":3,"title":"1.4.小结","slug":"_1-4-小结","link":"#_1-4-小结","children":[]}]},{"level":2,"title":"② 搭建哨兵集群","slug":"_2-搭建哨兵集群","link":"#_2-搭建哨兵集群","children":[]},{"level":2,"title":"③ RedisTemplate","slug":"_3-redistemplate","link":"#_3-redistemplate","children":[{"level":3,"title":"3.1.导入Demo工程","slug":"_3-1-导入demo工程","link":"#_3-1-导入demo工程","children":[]},{"level":3,"title":"3.2.引入依赖","slug":"_3-2-引入依赖","link":"#_3-2-引入依赖","children":[]},{"level":3,"title":"3.3.配置Redis地址","slug":"_3-3-配置redis地址","link":"#_3-3-配置redis地址","children":[]},{"level":3,"title":"3.4.配置读写分离","slug":"_3-4-配置读写分离","link":"#_3-4-配置读写分离","children":[]}]}],"filePathRelative":"docs/Middleware/Redis/Redis_Heima/3_Redis_Advanced/1_Redis_Advanced_Distributed/4-Redis_Advanced_Distributed.md","git":{"createdTime":1750319780000,"updatedTime":1750319780000,"contributors":[{"name":"lixuan","email":"2789968443@qq.com","commits":1}]}}');export{R as comp,f as data};
